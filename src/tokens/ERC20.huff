/// @title ERC20.huff
/// @author Andreas Bigger
/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.
/// @notice Modified from Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)

/* Imports */
#include "../data-structures/HashMap.huff"

/* Events */
#define event Transfer(address,address,uint256)
#define event Approve(address,address,uint256)
#define constant TRANSFER_EVENT_SIGNATURE = 0xDDF252AD1BE2C89B69C2B068FC378DAA952BA7F163C4A11628F55A4DF523B3EF
#define constant APPROVAL_EVENT_SIGNATURE = 0x8C5BE1E5EBEC7D5BD14F71427D1E84F3DD0314C0F7B2291E5B200AC8C7C3B925

/* Metadata */
#define function name() view returns (string)
#define function symbol() view returns (string)
#define function decimals() view returns (uint8)
#define function DOMAIN_SEPARATOR() view returns (bytes32)

/* Accessors */
#define function totalSupply() view returns (uint256)
#define function balanceOf(address) view returns (uint256)
#define function allowance(address, address) view returns (uint256)

/* EIP-2612 */
#define function nonces(address) view returns (uint256)

/* Mutators */
#define function transfer(address, uint256) nonpayable returns ()
#define function transferFrom(address, address, uint256) nonpayable returns ()
#define function approve(address, uint256) nonpayable returns ()
#define function permit(address, address, uint256, uint256, uint8, bytes32, bytes32)

/* Constructor */
#define function constructor(string, string, uint8) nonpayable returns ()

/* Storage Slots */
#define constant NAME_LOCATION = FREE_STORAGE_POINTER()
#define constant SYMBOL_LOCATION = FREE_STORAGE_POINTER()
#define constant DECIMALS_LOCATION = FREE_STORAGE_POINTER()
#define constant BALANCE_LOCATION = FREE_STORAGE_POINTER()
#define constant ALLOWANCE_LOCATION = FREE_STORAGE_POINTER()
#define constant TOTAL_SUPPLY_LOCATION = FREE_STORAGE_POINTER()

/* Immutables */
#define constant INITIAL_CHAIN_ID = FREE_STORAGE_POINTER()
#define constant INITIAL_DOMAIN_SEPARATOR = FREE_STORAGE_POINTER()

/* Constructor */
#define macro CONSTRUCTOR() = takes(0) returns (0) {
    // Load the calldata args
    0x44 calldataload                               // [decimals]
    0x24 calldataload                               // [symbol, decimals]
    0x04 calldataload                               // [name, symbol, decimals]

    [NAME_LOCATION] sstore                          // [symbol, decimals]
    [SYMBOL_LOCATION] sstore                        // [decimals]
    [DECIMALS_LOCATION] sstore                      // []

    // Store the chain id
    chainid [INITIAL_CHAIN_ID] sstore               // []

    // Compute the domain separator
    COMPUTE_DOMAIN_SEPARATOR()                      // [domainSeparator]
    [INITIAL_DOMAIN_SEPARATOR] sstore               // []
}

/* Compute the domain separator */
#define macro COMPUTE_DOMAIN_SEPARATOR() = takes (0) returns (1) {
    0x40        // [64]
    <mem_ptr>   // [<mem_ptr>, 64]
    sha3        // [key]
}

/* Domain Separator */
#define macro GET_DOMAIN_SEPARATOR() = takes (0) returns (0) {
    chainid [INITIAL_CHAIN_ID] sload                // [chainid, INITIAL_CHAIN_ID]
    eq ret jumpi                                    // []
    COMPUTE_DOMAIN_SEPARATOR()                      // [domainSeparator]
    0x00 mstore                                     // []
    0x20 0x00 return                                // []

    ret:
        [INITIAL_DOMAIN_SEPARATOR] sload            // [INITIAL_DOMAIN_SEPARATOR]
        0x00 mstore                                 // []
        0x20 0x00 return                            // []
}

/* Accounting Functions */
#define macro BALANCE_OF() = takes (0) returns (0) {
    0x04 calldataload                               // [account]
    [BALANCE_LOCATION] LOAD_ELEMENT_FROM_KEYS(0x00) // [balance]
    0x00 mstore                                     // []
    0x20 0x00 return                                // []
}

#define macro TOTAL_SUPPLY() = takes (0) returns (0) {
    [TOTAL_SUPPLY_LOCATION] sload   // [supply]
    0x00 mstore                     // []
    0x20 0x00 return                // []
}

#define macro ALLOWANCE() = takes (0) returns (0) {
    0x24 calldataload               // [to]
    0x04 calldataload               // [from, to]
    LOAD_ELEMENT_FROM_KEYS(0x00)    // [value]
    
    0x00 mstore
    0x20 0x00 return
}


/* Transfer Functions */
#define macro TRANSFER_TAKE_FROM(error) = takes(3) returns (3) {
    // Ensure that the sender has a sufficient balance.
    // input stack: [value, from, to]
    dup2                // [from, value, from, to]
    [BALANCE_LOCATION] LOAD_ELEMENT_FROM_KEYS(0x00)  // [balance, value, from, to]
    dup1                // [balance, balance, value, from, to]
    dup3                // [value, balance, balance, value, from, to]
    gt                  // [value>balance, balance, value, from, to]
    <error> jumpi       // [balance, value, from, to]

    // Update the sender's balance.
    // input stack: [balance, value, from, to]
    dup2                // [value, balance, value, from, to]
    swap1               // [balance, value, value, from, to]
    sub                 // [balance - value, value, from, to]
    dup3                // [from, balance-value, value, from, to]
    [BALANCE_LOCATION] STORE_ELEMENT_FROM_KEYS(0x00) // [value, from, to]
}

#define macro TRANSFER_GIVE_TO() = takes(3) returns (0) {
    // Update the balance of the recipient.
    // input stack: [value, from, to]
    dup3                // [to, value, from, to]
    dup2                // [value, to, value, from, to]
    swap1               // [to, value, value, from, to]
    [BALANCE_LOCATION] LOAD_ELEMENT_FROM_KEYS(0x00)  // [balance, value, value, from, to]
    add                 // [balance+value, value, from, to]
    dup4                // [to, balance+value, value, from, to]
    [BALANCE_LOCATION] STORE_ELEMENT_FROM_KEYS(0x00) // [value, from, to]
}

#define macro APPROVE() = takes (0) returns (0) {
    0x24 calldataload       // [value]
    0x04 calldataload       // [to, value]
    caller                  // [from, to, value]

    STORE_ELEMENT_FROM_KEYS(0x00)
}

#define macro TRANSFER() = takes(0) returns(1) {
    // Setup the stack for the transfer function.
    0x04 calldataload   // [to]
    caller              // [from, to]
    0x24 calldataload   // [value, from, to]

    // Update the balances of the sender and recipient.
    TRANSFER_TAKE_FROM(error)   // [value, from, to]
    TRANSFER_GIVE_TO()          // [value, from, to]

    // Emit the transfer event.
    0x00 mstore                 // [from, to]
    [TRANSFER_EVENT_SIGNATURE]  // [sig, from, to]
    0x20 0x00                   // [0, 32, sig, from, to]
    log3                        // []

    // Return "1" to represent a succesful transfer.
    0x01 0x00 mstore
    0x20 0x00 return

    // Error destination.
    error:
        0x00 0x00 revert
}

/**********************************/
/* INTERNAL MINT & BURN FUNCTIONS */
/**********************************/

/* [INTERNAL] Mint */
#define macro MINT() = takes(0) returns (0) {
    // Ensure that the sender is the owner of the contract.
    ONLY_OWNER()

    // Setup the stack for the mint function.
    0x04 calldataload   // [to]
    0x00                // [from (0x00), to]
    0x24 calldataload   // [value, from, to]

    // Give tokens to the recipient.
    TRANSFER_GIVE_TO()  // [value, from, to]

    // Update totalSupply
    dup1                            // [value, value, from, to]
    [TOTAL_SUPPLY_LOCATION] sload    // [supply,value,value,from,to]
    add                             // [supply+value,value,from,to]
    [TOTAL_SUPPLY_LOCATION] sstore  // [value,from,to]


    // Emit the transfer event.
    0x00 mstore                 // [from, to]
    [TRANSFER_EVENT_SIGNATURE]  // [sig, from, to]
    0x20 0x00                   // [0, 32, sig, from, to]
    log3                        // []
}

/* [INTERNAL] Burn */
/* - Jumps to <error> if the from has an insufficient balance */
#define macro BURN(error) = takes(0) returns (0) {
    // Setup the stack for the mint function.
    0x00                               // [(0x00)]
    0x04 calldataload                  // [from, (0x00)]
    0x24 calldataload                  // [amount, from, (0x00)]

    // Transfer the tokens to the 0 address
    TRANSFER_TAKE_FROM(<error>)          // [amount, from, (0x00)]
    TRANSFER_GIVE_TO()                 // [amount, from, (0x00)]

    // Less the totalSupply
    dup1                               // [amount, amount, from, (0x00)]
    [TOTAL_SUPPLY_LOCATION] sload      // [supply, amount, amount, from, (0x00)]
    add                                // [supply - amount, amount, from, (0x00)]
    [TOTAL_SUPPLY_LOCATION] sstore     // [amount, from, (0x00)]

    // Emit the transfer event.
    0x00 mstore                        // [from, (0x00)]
    [TRANSFER_EVENT_SIGNATURE]         // [sig, from, (0x00)]
    0x20 0x00                          // [0, 32, sig, from, (0x00)]
    log3                               // []
}

/**************/
/* MAIN MACRO */
/**************/

/* Main */
#define macro MAIN() = takes(0) returns (0) {
    0x00 calldataload 0xE0 shr
    dup1 0xa9059cbb eq transfer jumpi
    dup1 0x40c10f19 eq mints jumpi
    dup1 0x70a08231 eq balanceOf jumpi
    dup1 0x18160ddd eq totalSupply jumpi
    dup1 0x095ea7b3 eq approve jumpi
    dup1 0xdd62ed3e eq allowance jumpi

    // Revert if no selector matches
    0x00 0x00 revert

    transfer:
        TRANSFER()
    balanceOf:
        BALANCE_OF()
    totalSupply:
        TOTAL_SUPPLY()
    approve:
        APPROVE()
    allowance:
        ALLOWANCE()

}