/// @title ERC20.huff
/// @author asnared <https://github.com/abigger87>
/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.
/// @notice Modified from Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)

/* Imports */
#include "../data-structures/HashMap.huff"

/* Events */
#define event Transfer(address indexed, address indexed, uint256)
#define event Approve(address indexed, address indexed, uint256)
#define constant TRANSFER_EVENT_SIGNATURE = 0xDDF252AD1BE2C89B69C2B068FC378DAA952BA7F163C4A11628F55A4DF523B3EF
#define constant APPROVAL_EVENT_SIGNATURE = 0x8C5BE1E5EBEC7D5BD14F71427D1E84F3DD0314C0F7B2291E5B200AC8C7C3B925

/* Metadata */
#define function name() view returns (string)
#define function symbol() view returns (string)
#define function decimals() view returns (uint8)
#define function DOMAIN_SEPARATOR() view returns (bytes32)

/* Accessors */
#define function totalSupply() view returns (uint256)
#define function balanceOf(address) view returns (uint256)
#define function allowance(address, address) view returns (uint256)

/* EIP-2612 */
#define function nonces(address) view returns (uint256)

/* Mutators */
#define function transfer(address, uint256) nonpayable returns ()
#define function transferFrom(address, address, uint256) nonpayable returns ()
#define function approve(address, uint256) nonpayable returns ()
#define function permit(address, address, uint256, uint256, uint8, bytes32, bytes32) nonpayable returns ()

/* Constructor */
#define function constructor(string, string, uint8) nonpayable returns ()

/* Storage Slots */
#define constant NAME_LOCATION = FREE_STORAGE_POINTER()
#define constant SYMBOL_LOCATION = FREE_STORAGE_POINTER()
#define constant DECIMALS_LOCATION = FREE_STORAGE_POINTER()
#define constant BALANCE_LOCATION = FREE_STORAGE_POINTER()
#define constant ALLOWANCE_LOCATION = FREE_STORAGE_POINTER()
#define constant TOTAL_SUPPLY_LOCATION = FREE_STORAGE_POINTER()

/* Immutables */
#define constant INITIAL_CHAIN_ID = FREE_STORAGE_POINTER()
#define constant INITIAL_DOMAIN_SEPARATOR = FREE_STORAGE_POINTER()

/* Domain Separater Byte String */
/* total - 86 bytes = 0x54 */
#define constant DOMAIN_ONE_SEPARATOR_STR = 0x454950373132446f6d61696e28737472696e67206e616d652c737472696e6720 // 32 bytes
#define constant DOMAIN_TWO_SEPARATOR_STR = 0x76657273696f6e2c75696e7432353620636861696e49642c6164647265737320 // 32 bytes
#define constant DOMAIN_THREE_SEPARATOR_STR = 0x766572696679696e67436f6e747261637429 // 18 bytes

/* Constructor */
#define macro CONSTRUCTOR() = takes(0) returns (0) {
    // Copy the decimals into memory
    0x20                        // [size] - byte size to copy
    0x20 codesize sub           // [offset, size] - offset in the code to copy from
    0x00                        // [mem, offset, size] - offset in memory to copy to
    codecopy                    // []
    0x00 mload                  // [decimals]

    // Copy the symbol into memory
    0x20                        // [size, decimals] - byte size to copy
    0x40 codesize sub           // [offset, size, decimals] - offset in the code to copy from
    0x00                        // [mem, offset, size, decimals] - offset in memory to copy to
    codecopy                    // [decimals]
    0x00 mload                  // [symbol, decimals]

    // Copy the name into memory
    0x20                        // [size, symbol, decimals] - byte size to copy
    0x60 codesize sub           // [offset, size, symbol, decimals] - offset in the code to copy from
    0x00                        // [mem, offset, size, symbol, decimals] - offset in memory to copy to
    codecopy                    // [symbol, decimals]
    0x00 mload                  // [name, symbol, decimals]

    // TODO: optimize initial domain separator computation by saving metadata on stack
    [NAME_LOCATION] sstore                     // [name, symbol, decimals]
    [SYMBOL_LOCATION] sstore                   // [name, symbol, decimals]
    [DECIMALS_LOCATION] sstore                 // [name, symbol, decimals]

    // Store the chain id
    chainid [INITIAL_CHAIN_ID] sstore               // []

    // Compute the domain separator
    COMPUTE_DOMAIN_SEPARATOR()                      // [domainSeparator]
    [INITIAL_DOMAIN_SEPARATOR] sstore               // []
}

/* Compute the domain separator */
#define macro COMPUTE_DOMAIN_SEPARATOR() = takes (0) returns (1) {
    // First hash the eip 712 identifier
    // store in mem slot 0
    [DOMAIN_ONE_SEPARATOR_STR] 0x00 mstore          // []
    [DOMAIN_TWO_SEPARATOR_STR] 0x20 mstore          // []
    [DOMAIN_THREE_SEPARATOR_STR] 0x40 mstore        // []
    0x54 0x00 sha3                                  // [712_hash]

    // Name hash + store in mem slot 1
    [NAME_LOCATION] sload 0x00 mstore               // [712_hash]
    0x20 0x00 sha3                                  // [name_hash, 712_hash]

    // Hash "1" + store in mem slot 2
    0x31 0x40 mstore                                // [name_hash, 712_hash]
    0x02 0x00 sha3                                  // [one_hash, name_hash, 712_hash]
    0xC0 mstore                                     // [name_hash, 712_hash]
    0xA0 mstore                                     // [712_hash]
    0x80 mstore                                     // []

    // Store chain id in mem slot 3
    chainid 0xE0 mstore                             // []

    // Store address(this) in slot 4
    address 0x0100 mstore                           // []

    // keccak256 compute out separator
    0xA0                                            // [size]
    0x80                                            // [offset, size]
    sha3                                            // [hash]
}

/* Domain Separator */
#define macro GET_DOMAIN_SEPARATOR() = takes (0) returns (0) {
    chainid [INITIAL_CHAIN_ID] sload                // [chainid, INITIAL_CHAIN_ID]
    eq ret jumpi                                    // []
    COMPUTE_DOMAIN_SEPARATOR()                      // [domainSeparator]
    0x00 mstore                                     // []
    0x20 0x00 return                                // []

    ret:
        [INITIAL_DOMAIN_SEPARATOR] sload            // [INITIAL_DOMAIN_SEPARATOR]
        0x00 mstore                                 // []
        0x20 0x00 return                            // []
}

/* Accounting Functions */
#define macro BALANCE_OF() = takes (0) returns (0) {
    0x04 calldataload                               // [account]
    [BALANCE_LOCATION] LOAD_ELEMENT_FROM_KEYS(0x00) // [balance]
    0x00 mstore                                     // []
    0x20 0x00 return                                // []
}

#define macro TOTAL_SUPPLY() = takes (0) returns (0) {
    [TOTAL_SUPPLY_LOCATION] sload   // [supply]
    0x00 mstore                     // []
    0x20 0x00 return                // []
}

#define macro ALLOWANCE() = takes (0) returns (0) {
    0x24 calldataload               // [to]
    0x04 calldataload               // [from, to]
    LOAD_ELEMENT_FROM_KEYS(0x00)    // [value]

    0x00 mstore
    0x20 0x00 return
}


/* Transfer Functions */
#define macro TRANSFER_TAKE_FROM(error) = takes(3) returns (3) {
    // Ensure that the sender has a sufficient balance.
    // input stack: [value, from, to]
    dup2                // [from, value, from, to]
    [BALANCE_LOCATION] LOAD_ELEMENT_FROM_KEYS(0x00)  // [balance, value, from, to]
    dup1                // [balance, balance, value, from, to]
    dup3                // [value, balance, balance, value, from, to]
    gt                  // [value>balance, balance, value, from, to]
    <error> jumpi       // [balance, value, from, to]

    // Update the sender's balance.
    // input stack: [balance, value, from, to]
    dup2                // [value, balance, value, from, to]
    swap1               // [balance, value, value, from, to]
    sub                 // [balance - value, value, from, to]
    dup3                // [from, balance-value, value, from, to]
    [BALANCE_LOCATION] STORE_ELEMENT_FROM_KEYS(0x00) // [value, from, to]
}

#define macro TRANSFER_GIVE_TO() = takes(3) returns (0) {
    // Update the balance of the recipient.
    // input stack: [value, from, to]
    dup3                // [to, value, from, to]
    dup2                // [value, to, value, from, to]
    swap1               // [to, value, value, from, to]
    [BALANCE_LOCATION] LOAD_ELEMENT_FROM_KEYS(0x00)  // [balance, value, value, from, to]
    add                 // [balance+value, value, from, to]
    dup4                // [to, balance+value, value, from, to]
    [BALANCE_LOCATION] STORE_ELEMENT_FROM_KEYS(0x00) // [value, from, to]
}

#define macro APPROVE() = takes (0) returns (0) {
    0x24 calldataload       // [value]
    dup1 0x00 mstore        // [value]
    0x04 calldataload       // [to, value]
    caller                  // [from, to, value]

    // Emit the approval event.
    dup2 dup2                                   // [from, to, from, to, value]
    [APPROVAL_EVENT_SIGNATURE]
   // __EVENT_HASH(APPROVAL_EVENT_SIGNATURE)      // [sig, from, to, from, to, value]
    0x20 0x00                                   // [0, 32, sig, from, to, from, to, value]
    log3                                        // [from, to, value]

    // Store the value at slot = keccak256(from . to)
    STORE_ELEMENT_FROM_KEYS(0x00)
}

#define macro TRANSFER() = takes(0) returns(1) {
    // Setup the stack for the transfer function.
    0x04 calldataload   // [to]
    caller              // [from, to]
    0x24 calldataload   // [value, from, to]

    // Update the balances of the sender and recipient.
    TRANSFER_TAKE_FROM(error)   // [value, from, to]
    TRANSFER_GIVE_TO()          // [value, from, to]

    // Emit the transfer event.
    0x00 mstore                 // [from, to]
    [TRANSFER_EVENT_SIGNATURE]  // [sig, from, to]
    0x20 0x00                   // [0, 32, sig, from, to]
    log3                        // []

    // Return "1" to represent a succesful transfer.
    0x01 0x00 mstore
    0x20 0x00 return

    // Error destination.
    error:
        0x00 0x00 revert
}

/**********************************/
/* INTERNAL MINT & BURN FUNCTIONS */
/**********************************/

/* [INTERNAL] Mint */
#define macro MINT() = takes(0) returns (0) {
    // Load Calldata
    0x04 calldataload                   // [to]
    0x00                                // [from, to]
    0x24 calldataload                   // [value, from, to]

    // Give tokens to the recipient.
    TRANSFER_GIVE_TO()                  // [value, from, to]

    // Update totalSupply
    dup1                                // [value, value, from, to]
    [TOTAL_SUPPLY_LOCATION] sload       // [supply, value, value, from, to]
    add                                 // [supply + value, value, from, to]
    [TOTAL_SUPPLY_LOCATION] sstore      // [value, from, to]

    // Emit the transfer event.
    0x00 mstore                         // [from, to]
    [TRANSFER_EVENT_SIGNATURE]          // [sig, from, to]
    0x20 0x00                           // [0, 32, sig, from, to]
    log3                                // []
}

/* [INTERNAL] Burn */
/* - Jumps to <error> if the from has an insufficient balance */
#define macro BURN(error) = takes(0) returns (0) {
    // Setup the stack for the mint function.
    0x00                               // [(0x00)]
    0x04 calldataload                  // [from, (0x00)]
    0x24 calldataload                  // [amount, from, (0x00)]

    // Transfer the tokens to the 0 address
    TRANSFER_TAKE_FROM(<error>)          // [amount, from, (0x00)]
    TRANSFER_GIVE_TO()                 // [amount, from, (0x00)]

    // Less the totalSupply
    dup1                               // [amount, amount, from, (0x00)]
    [TOTAL_SUPPLY_LOCATION] sload      // [supply, amount, amount, from, (0x00)]
    add                                // [supply - amount, amount, from, (0x00)]
    [TOTAL_SUPPLY_LOCATION] sstore     // [amount, from, (0x00)]

    // Emit the transfer event.
    0x00 mstore                        // [from, (0x00)]
    [TRANSFER_EVENT_SIGNATURE]         // [sig, from, (0x00)]
    0x20 0x00                          // [0, 32, sig, from, (0x00)]
    log3                               // []
}

#define macro NAME() = takes(0) returns(0) {
    [NAME_LOCATION] sload              // [name]
    0x00 mstore                        // []
    0x20 0x00 return                   // []
}

#define macro SYMBOL() = takes(0) returns(0) {
    [SYMBOL_LOCATION] sload            // [symbol]
    0x00 mstore                        // []
    0x20 0x00 return                   // []
}

#define macro DECIMALS() = takes(0) returns(0) {
    [DECIMALS_LOCATION] sload          // [decimals]
    0x00 mstore                        // []
    0x20 0x00 return                   // []
}