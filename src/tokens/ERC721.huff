/// @title ERC721
/// @author asnared <https://github.com/abigger87>
/// @author kadenzipfel <https://github.com/kadenzipfel>
/// @notice Modern and heavily gas golfed ERC-721 implementation
/// @notice Adapted from Solmate https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol

// Imports
#include "../utils/CommonErrors.huff"
#include "../utils/NonPayable.huff"
#include "../data-structures/Hashmap.huff"

// Interface
#define function name() nonpayable returns (string)
#define function symbol() nonpayable returns (string)
#define function tokenURI(uint256) nonpayable returns (string)

#define function mint(address, uint256) payable returns ()
#define function burn(uint256) nonpayable returns ()

#define function transfer(address,uint256) nonpayable returns ()
#define function transferFrom(address,address,uint256) nonpayable returns ()
#define function approve(address,uint256) nonpayable returns ()
#define function setApprovalForAll(address,bool) nonpayable returns ()

#define function getApproved(uint256) view returns (address)
#define function isApprovedForAll(address,address) view returns (bool)
#define function ownerOf(uint256) view returns (address)
#define function balanceOf(address) view returns (uint256)
#define function supportsInterface(bytes4) view returns (bool)

// Events
#define event Transfer(address,address,uint256)
#define event Approval(address,address,uint256)
#define event ApprovalForAll(address,address,bool)

// Storage Slots
#define constant OWNER_LOCATION = FREE_STORAGE_POINTER() // ownerOf
#define constant BALANCE_LOCATION = FREE_STORAGE_POINTER() // balanceOf
#define constant SINGLE_APPROVAL_LOCATION = FREE_STORAGE_POINTER() // getApproved

// Metadata
// META_NAME = "Token"
#define constant META_NAME = 0x546f6b656e000000000000000000000000000000000000000000000000000000
#define constant META_NAME_LENGTH = 0x05

// META_SYMBOL = "TKN"
#define constant META_SYMBOL = 0x544B4E0000000000000000000000000000000000000000000000000000000000
#define constant META_SYMBOL_LENGTH = 0x03


/// >>>>>>>>>>>>>>>>>>>>>  VIEW FUNCTIONS  <<<<<<<<<<<<<<<<<<<<<< ///

/// @notice Name
/// @notice Returns the token name string
#define macro NAME() = takes (0) returns (0) {
    NON_PAYABLE()                       // []
    0x20 0x00 mstore                    // []
    [META_NAME_LENGTH] 0x20 mstore      // []
    [META_NAME] 0x40 mstore             // []
    0x60 0x00 return                    // []
}

/// @notice Symbol
/// @notice Returns the symbol of the token
#define macro SYMBOL() = takes (0) returns (0) {
    NON_PAYABLE()                       // []
    0x20 0x00 mstore                    // []
    [META_SYMBOL_LENGTH] 0x20 mstore    // []
    [META_SYMBOL] 0x40 mstore           // []
    0x60 0x00 return                    // []
}

/// @notice Balance Of
/// @notice Returns the balance of the given address
#define macro BALANCE_OF() = takes (0) returns (0) {
    NON_PAYABLE()                                       // []
    0x04 calldataload                                   // [account]
    [BALANCE_LOCATION] LOAD_ELEMENT_FROM_KEYS(0x00)     // [balance]
    0x00 mstore                                         // []
    0x20 0x00 return                                    // []
}

/// @notice Owner Of
/// @notice Returns the owner of the given token id
#define macro OWNER_OF() = takes (0) returns (0) {
    0x04 calldataload                               // [tokenId]
    [OWNER_LOCATION] LOAD_ELEMENT_FROM_KEYS(0x00)   // [owner]
    0x00 mstore                                     // []
    0x20 0x00 return                                // []
}

/// @notice Is Approved For All
/// @notice Returns whether the given operator is approved for all tokens of the given owner
#define macro IS_APPROVED_FOR_ALL() = takes (0) returns (0) {
    0x24 calldataload               // [to]
    0x04 calldataload               // [from, to]
    LOAD_ELEMENT_FROM_KEYS(0x00)    // [value]
    0x00 mstore                     // []
    0x20 0x00 return                // []
}

/// @notice Get Approved
/// @notice Returns the approved address for the given token id
#define macro GET_APPROVED() = takes (0) returns (0) {
    0x04 calldataload               // [tokenId]
    [SINGLE_APPROVAL_LOCATION]      // [approval_slot, tokenId]
    LOAD_ELEMENT_FROM_KEYS(0x00)    // [spender]
    0x00 mstore                     // []
    0x20 0x00 return                // []
}


#define macro TOKEN_URI() = takes (0) returns (0) {
    0x00 0x00 revert
}

#define macro SUPPORTS_INTERFACE() = takes (0) returns (0) {
    // grab interfaceId
    0x04 calldataload       // [interfaceId]
    0xe0
    shr

    // check if erc165 interfaceId
    dup1                    // [interfaceId, interfaceId]
    0x01ffc9a7 eq           // [is_erc165, interfaceId]
    is_interface jumpi

    // check if erc721 interfaceId
    dup1                    // [interfaceId, interfaceId]
    0x80ac58cd eq           // [is_erc721, interfaceId]
    is_interface jumpi

    // check if erc721Metadata interfaceId
    0x5b5e139f eq           // [is_erc721Metadata]
    is_interface jumpi

    0x00 mstore             // []
    0x20 0x00 return        // []

    is_interface:
        pop                 // []
        0x01 0x00 mstore    // []
        0x20 0x00 return    // []
}

/// >>>>>>>>>>>>>>>>>>>>>  INTERNAL FUNCTIONS  <<<<<<<<<<<<<<<<<<<<<< ///

/// @notice Mint
/// @notice Mints a new token
/// @dev The Mint function is payable
#define macro _MINT() = takes (2) returns (0) {
    // Input stack:                                 // [to, tokenId]

    // Check that the recipient is valid
    dup1 iszero invalid_recipient jumpi             // [to, tokenId]

    // Create the minting params
    0x00                                            // [from (0x00), to, tokenId]
    dup3                                            // [tokenId, from (0x00), to, tokenId]

    // Check token ownership
    [OWNER_LOCATION] LOAD_ELEMENT_FROM_KEYS(0x00)   // [owner, from (0x00), to, tokenId]
    iszero iszero unauthorized jumpi

    // Give tokens to the recipient.
    TRANSFER_GIVE_TO()                              // [from (0x00), to, tokenId]

    // Emit the transfer event.
    __EVENT_HASH(Transfer)                          // [sig, from (0x00), to, tokenId]
    0x00 0x00                                       // [0, 0, sig, from (0x00), to, tokenId]
    log4                                            // []

    stop

    invalid_recipient:
        INVALID_RECIPIENT(0x00)

    unauthorized:
        ALREADY_MINTED(0x00)
}

/// @notice Burn
/// @notice Burns the token with the given id
#define macro _BURN() = takes (1) returns (0) {
    // Input stack:                                 // [tokenId]
    NON_PAYABLE()                                   // [tokenId]

    dup1                                            // [tokenId, tokenId]
    [OWNER_LOCATION] LOAD_ELEMENT_FROM_KEYS(0x00)   // [owner, tokenId]

    // Check that the recipient is valid
    dup1 iszero                                     // [owner == 0, owner, tokenId]
    not_minted jumpi                                // [owner, tokenId]

    // Create the burning params
    0x00 swap1                                      // [owner, to (0x00), tokenId]

    // Reduce the balance of owner by 1
    0x01 dup2                                       // [owner, 1, owner, to, tokenId]
    [BALANCE_LOCATION] LOAD_ELEMENT_FROM_KEYS(0x00) // [balance, 1, owner, to, tokenId]
    sub dup2                                        // [owner, balance-1, owner, to, tokenId]
    [BALANCE_LOCATION]
    STORE_ELEMENT_FROM_KEYS(0x00)                   // [owner, to, tokenId]

    // Set the owner of the token to 0x00
    0x00 dup4 [OWNER_LOCATION]                      // [slot, owner, 0x00, owner, to, tokenId]
    STORE_ELEMENT_FROM_KEYS(0x00)                   // [owner, to, tokenId]

    // Set the approval of the token to 0x00 for the owner
    0x00 dup4 [SINGLE_APPROVAL_LOCATION]            // [slot, owner, 0x00, owner, to, tokenId]
    STORE_ELEMENT_FROM_KEYS(0x00)                   // [owner, to, tokenId]

    // Emit the transfer event.
    __EVENT_HASH(Transfer)                          // [sig, owner, to (0x00), tokenId]
    0x00 0x00                                       // [0, 0, sig, owner, to (0x00), tokenId]
    log4                                            // []

    stop

    not_minted:
        NOT_MINTED(0x00)
}

/// >>>>>>>>>>>>>>>>>>>>>  EXTERNAL FUNCTIONS  <<<<<<<<<<<<<<<<<<<<<< ///

/// @notice Transfer From
#define macro TRANSFER_TAKE_FROM(error) = takes(3) returns (3) {
    // input stack [from, to, tokenId]

    // check if from is the owner of the token
    dup1                                            // [from, from, to, tokenId]
    dup4                                            // [tokenId, from, from, to, tokenId]
    [OWNER_LOCATION] LOAD_ELEMENT_FROM_KEYS(0x00)   // [owner, from, from, to, tokenId]
    swap2                                           // [from, owner, from, to, tokenId]
    eq                                              // [from_is_owner, from, to, tokenId]
    cont jumpi                                      // [from, to, tokenId]
        <error> jump
    cont:

    // check if msg.sender == from
    dup1 caller                                     // [msg.sender, from, from, to, tokenId]
    eq                                              // [from_is_msg.sender, from, to, tokenId]
    is_authorized jumpi                             // [from, to, tokenId]

    // check if approved for all
    caller dup2                                     // [from, msg.sender, from, to, tokenId]
    LOAD_ELEMENT_FROM_KEYS(0x00)                    // [is_approved_for_all, from, to, tokenId]
    is_authorized jumpi                             // [from, to, tokenId]

    // check if approved for tokenId
    dup3                                            // [tokenId, from, to, tokenId]
    [SINGLE_APPROVAL_LOCATION]                      // [SINGLE_APPROVAL_LOCATION, tokenId, from, to, tokenId]
    LOAD_ELEMENT_FROM_KEYS(0x00)                    // [address_approved_for_tokenId, from, to, tokenId]
    caller eq                                       // [msg.sender_approved_for_tokenId, from, to, tokenId]
    is_authorized jumpi                             // [from, to, tokenId]
        <error> jump
    is_authorized:

    // update balance of from
    0x01 dup2                                       // [from, 1, from, to, tokenId]
    [BALANCE_LOCATION] LOAD_ELEMENT_FROM_KEYS(0x00) // [balance, 1, from, to, tokenId]
    sub dup2                                        // [from, balance-1, from, to, tokenId]
    [BALANCE_LOCATION]
    STORE_ELEMENT_FROM_KEYS(0x00)                   // [from, to, tokenId]

}

#define macro TRANSFER_GIVE_TO() = takes(3) returns (3) {
    // retrieve balance
    // input stack:                 // [from, to, tokenId]
    dup2                            // [to, from, to, tokenId]
	[BALANCE_LOCATION]
    LOAD_ELEMENT_FROM_KEYS(0x00)    // [balance, from, to, tokenId]
    0x01 add                        // [balance+1, from, to, tokenId]

    // update balance
	dup3                            // [to, balance+1, from, to, tokenId]
    [BALANCE_LOCATION]
    STORE_ELEMENT_FROM_KEYS(0x00)   // [from, to, tokenId]

    // update ownerOf
    dup2                            // [to, from, to, tokenId]
    dup4                            // [tokenId, to, from, to, tokenId]
    [OWNER_LOCATION]
    STORE_ELEMENT_FROM_KEYS(0x00)   // [from, to, tokenId]

    // update approval
    0x00 dup4                       // [tokenId, address(0), from, to, tokenId]
    [SINGLE_APPROVAL_LOCATION]
    STORE_ELEMENT_FROM_KEYS(0x00)   // [from, to, tokenId]
}

/// @notice Approve
/// @notice Approves a spender for a specific token
#define macro APPROVE() = takes (0) returns (0) {
    // get owner
    0x24 calldataload dup1          // [tokenId, tokenId]
    [OWNER_LOCATION]
    LOAD_ELEMENT_FROM_KEYS(0x00)    // [owner, tokenId]
    dup1 caller                     // [msg.sender, owner, owner, tokenId]
    eq                              // [is_sender_owner, owner, tokenId]

    // check if approved for all
    caller dup3                     // [owner, msg.sender, is_sender_owner, owner, tokenId]
    LOAD_ELEMENT_FROM_KEYS(0x00)    // [is_approved_for_all, is_sender_owner, owner, tokenId]]
    or cont jumpi                   // [owner, tokenId]
        not_authorized jump
    cont:

    // store approval
    0x04 calldataload dup1 dup4     // [tokenId, spender, spender, owner, tokenId]
    [SINGLE_APPROVAL_LOCATION]
    STORE_ELEMENT_FROM_KEYS(0x00)   // [spender, owner, tokenId]
    swap1                           // [owner, spender, tokenId]

    // emit the approval event
    __EVENT_HASH(Approval)                          // [sig, owner, spender, tokenId]
    0x00 0x00                                       // [0, 0, sig, owner, spender, tokenId]
    log4                                            // []

    stop

    not_authorized:
        UNAUTHORIZED(0x00)
}

/// @notice Set Approval For All
/// @notice Sets an operator as approved for all tokens of the caller
#define macro SET_APPROVAL_FOR_ALL() = takes (0) returns (0) {
    // Store the operator as approved for all
    0x24 calldataload                               // [approved]
    0x04 calldataload                               // [operator, approved]
    caller                                          // [msg.sender, operator, approved]
    STORE_ELEMENT_FROM_KEYS(0x00)                   // []

    // Emit the ApprovalForAll event
    0x24 calldataload                               // [approved]
    0x04 calldataload                               // [operator, approved]
    caller                                          // [msg.sender, operator, approved]
    __EVENT_HASH(ApprovalForAll)                    // [sig, owner, operator]
    0x00 0x00                                       // [0, 32, sig, owner, operator]
    log4                                            // []

    // Stop execution
    stop
}

#define macro TRANSFER_FROM() = takes(0) returns(0) {
    // Setup the stack for the transfer function.
    0x44 calldataload   // [tokenId]
    0x24 calldataload   // [to, tokenId]
    0x04 calldataload   // [from, to, tokenId]

    TRANSFER_TAKE_FROM(error)                       // [from, to, tokenId]
    TRANSFER_GIVE_TO()                              // [from, to, tokenId]

    // Emit the transfer event.
    __EVENT_HASH(Transfer)                          // [sig,from, to, tokenId]
    0x20 0x00                                       // [0, 0, sig, from, to, tokenId]
    log4                                            // []

    stop
    // Error destination.
    error:
        0x00 0x00 revert
}

#define macro SAFE_TRANSFER_FROM() = takes(0) returns (0) {
    0x00 0x00 revert
}

#define macro SAFE_TRANSFER_FROM_WITH_DATA() = takes(0) returns (0) {
    0x00 0x00 revert
}