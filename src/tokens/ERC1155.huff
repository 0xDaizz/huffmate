#include "../data-structures/Hashmap.huff"
#include "../math/SafeMath.huff"

/* Interface */

#define function mint(address,uint256,uint256,bytes) nonpayable returns ()
#define function batchMint(address,uint256[],uint256[],bytes) nonpayable returns ()

#define function burn(address,uint256,uint256) nonpayable returns ()
#define function batchBurn(address,uint256[],uint256[]) nonpayable returns ()

#define function safeTransferFrom(address,address,uint256,uint256,bytes) nonpayable returns ()
#define function safeBatchTransferFrom(address,address,uint256[],uint256[],bytes) nonpayable returns()
#define function setApprovalForAll(address,bool) nonpayable returns ()

/* View functions */
#define function getApproved(uint256) view returns (address)
#define function isApprovedForAll(address,address) view returns (bool)
#define function balanceOf(address,uint256) view returns (uint256)

#define function name() view returns (string)
#define function symbol() view returns (string)
#define function tokenURI(uint256) view returns (string)
#define function supportsInterface(bytes4) view returns (bool)

/* Events */
#define event TransferSingle(address,address,address,uint256,uint256)
#define event ApprovalForAll(address,address,bool)
#define event URI(string,uint256)

/* Event Signatures */
#define constant TRANSFER_SINGLE_SIGNATURE = 0xc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62
#define constant TRANSFER_BATCH_SIGNATURE = 0x13eb9248a9ef11cb06c98b58bfdc389b461152c8668d155983ad4e9d249a02a0
#define constant APPROVAL_FOR_ALL_EVENT_SIGNATURE = 0x2ce3f86be9eea89ec6cccd2733d6b5d5cbf20f592201255984d0178f76d55757
#define constant URI_EVENT_SIGNATURE = 0x6bb7ff708619ba0610cba295a58592e0451dee2622938c8755667688daf3529b

/* Storage Slots */
// Hard code these????? - save gas
#define constant NAME_LOCATION = FREE_STORAGE_POINTER()
#define constant SYMBOL_LOCATION = FREE_STORAGE_POINTER()
#define constant BALANCE_LOCATION = FREE_STORAGE_POINTER()
#define constant IS_APPROVED_FOR_ALL_LOCATION = FREE_STORAGE_POINTER()

/* Constructor */
#define macro CONSTRUCTOR() = takes(0) returns (0){
    
}

/* View functions */
#define macro BALANCE_OF() = takes(0) returns(0) {
    0x24 calldataload                               // [tokenId]     // 0x04 ignores function selector
    0x04 calldataload                               // [account, tokenId]
    
    [BALANCE_LOCATION] 
    LOAD_ELEMENT_FROM_KEYS_2D(0x00)                    // [val] <mem_ptr> is 0x0 <- no need for scratch space?>
    0x00 mstore                                     // [] load into mem
    0x20 0x00 return                                // [] return 32 bytes
}

#define macro NAME() = takes (0) returns (0) {
    // length 0b
    0x0b4855464645524331313535          // hufferc1155
    0x2b mstore                         // [] load into mem
    
    0x20 returndatasize mstore                    // dyn offset
    0x60 returndatasize return                     
}

#define macro SYMBOL() = takes (0) returns (0) {
    0x054831313535                      // h1155
    0x25 mstore

    0x20 returndatasize mstore
    0x60 returndatasize return
}

// TODO: pack tokenId onto end 0x04 calldataload
#define macro TOKEN_URI() = takes (0) returns (0) {
    // take the token id from calldata
    // ipfs://QmeSjSinHpPnmXmspMjwiXyN6zS4E9zccariGR3jxcaWtq/
    
    0x00 0x00 revert
}


// /* External functions */
#define macro SET_APPROVAL_FOR_ALL() = takes(0) returns(0){
    0x24 calldataload                   // [approved]
    
    dup1 0x00 mstore                    // store approved in memory for the log - optomise placing it where it will be used in the sha calculation
    
    0x04 calldataload                   // [operator, approved]
    caller                              // [msg.sender, operator, approved]

    dup2 dup2                           // [msg.sender, operator, msg.sender, operator, approved]

    // emit ApprovalForAll(msg.sender, operator, approved)
    [APPROVAL_FOR_ALL_EVENT_SIGNATURE]  // [sig, msg.sender, operator, msg.sender, operator, approved]
    0x20 0x00                           // [0x20, 0x00, sig, msg.sender, operator, msg.sender, operator, approved]
    log3                                // [msg.sender, operator, approved]

    [IS_APPROVED_FOR_ALL_LOCATION]      // [slot, msg.sender, operator, approved] 
    STORE_ELEMENT_FROM_KEYS_2D(0x00)    // []
    stop
}

#define macro IS_APPROVED_FOR_ALL() = takes(0) returns(0) {
    0x24 calldataload                 // [operator]
    0x04 calldataload                 // [owner, operator]
    
    [IS_APPROVED_FOR_ALL_LOCATION]    // [slot, owner, operator] 
    LOAD_ELEMENT_FROM_KEYS_2D(0x00)   // [val]
    
    0x00 mstore
    0x20 0x00 return
}

// address, tokenId, amount, data
#define macro MINT() = takes(0) returns (0){
    // increase the balance of the address # TODO: increment current balance
    0x44 calldataload       // [amount]
    
    // store for log
    dup1 0x60 mstore        // [amount]

    0x24 calldataload       // [tokenId, amount]

    // store for log
    dup1 0x40 mstore        // [tokenId, amount]

    0x04 calldataload       // [to, tokenId, amount]
    INCREASE_BALANCE(0x00)

    // emit transfer event    
    0x04 calldataload dup1  // [to]
    0x00                    // [zero_address, to, to]
    caller                  // [msg.sender, zero_address, to, to]
    [TRANSFER_SINGLE_SIGNATURE]     // [TransferSingle, msg.sender, zero_address, to, to] 
    0x40 0x40               // TODO
    log4                    // [to]

    0x00 swap1
    // [to, from]
    SAFE_CALL()
}


// TODO: optimize this
#define macro IS_OWNER_OR_APPROVED(error) = takes(0) returns(0){

    // check called by owner
    0x04 calldataload       // [from] 
    caller                  // [msg.sender, from]
    dup2                    // [from, msg.sender, from]     
    dup3                    // [from, msg.sender, from, msg.sender]
    eq continue jumpi       // [from, msg.sender]       
    
    // check sender is approved for all
    [IS_APPROVED_FOR_ALL_LOCATION]
    LOAD_ELEMENT_FROM_KEYS_2D(0x00)
    eq iszero <error> jumpi 

    continue:
}

// Optimize swaps
#define macro DECREASE_BALANCE() = takes(3) returns(0){
    // takes 3 [from, tokenId, amount]
    [BALANCE_LOCATION]              // [&balance, from, tokenId, amount]
    GET_SLOT_FROM_KEYS_2D(0x00)      // [slot, amount]
    dup1                            // [slot,slot,amount]
    sload                           // [bal, slot, amount]  
    swap1                           // [slot, bal, amount]
    swap2                           // [amount, bal, slot]
    swap1                           // [bal, amount, slot]
     
    // calc and store new sender balance // Safe sub balance to revert on underflow
    SAFE_SUB()                      // [(bal-amount), slot]
    
    // Store decreased balance
    swap1                           // [slot, (bal-amount)]
    sstore                          // []    
}

#define macro INCREASE_BALANCE() = takes(3) returns(0) {
    // takes3                       // [to, tokenId, amount]
    [BALANCE_LOCATION]              // [&balance, to, tokenId, amount]
    GET_SLOT_FROM_KEYS_2D(0x00)     // [slot, amount]
    dup1                            // [slot, slot,amount]
    sload                           // [bal, slot, amount]  
    swap1                           // [slot, bal, amount]
    swap2                           // [amount, bal, slot]
     
    // calc and store new sender balance // Safe sub balance to revert on underflow
    SAFE_ADD()                      // [(bal+amount), slot]
    
    // Store decreased balance
    swap1                           // [slot, (bal+amount)]
    sstore                          // []   
}

//  0x04, 0x24, 0x44, 0x64, 0x84
// (from, to, id, amount, data) 
// TODO, optimize
#define macro SAFE_TRANSFER_FROM() = takes(0) returns (0) {

    // data is currently ignored
    IS_OWNER_OR_APPROVED(error)

    // Decrease the balance of the from address
    0x64 calldataload               // [amount]
    0x44 calldataload               // [tokenId, amount]
    dup2 dup1                       // [amount, amount, tokenId, amount]
    dup3                            // [tokenId, amount, amount, tokenId, amount]
    0x04 calldataload               // [from, tokenId, amount, amount, tokenId, amount]
    DECREASE_BALANCE()              // [amount, tokenId, amount]    
    
    // Perform increase balance     // [amount, tokenId, amount]
    dup2                            // [tokenId, amount, tokenId, amount] 
    0x24 calldataload               // [to, tokenId, amount, tokenId, amount]
    INCREASE_BALANCE()

    // Emit transfer log            // [tokenId, amount]
    0x00 mstore                     // store tokenId in memory for log can store in 0x00 as scratch space is no longer in use
    0x20 mstore                     // store amount in memory for log           

    0x24 calldataload dup1          // [to, to]
    0x04 calldataload               // [from, to, to]
    caller                          // [msg.sender, from, to, to]
    [TRANSFER_SINGLE_SIGNATURE]     // [TransferSingle, msg.sender, from, to, to] 
    0x00 0x40                       // [to] log data
    log4

    SAFE_CALL()

    error: 
        0x00 dup1 revert
}


#define macro SAFE_CALL() = takes(2) returns(0) {
    // [to, from]

    // safe transfer
    // if the contract to has code

    dup1                            // [to, to, from]
    extcodesize                     // [codesize(to), to, to, from]
    iszero                          // [!(codesize(to)), to, to, from]
    iszero                          // [!!(codesize(to)), to, to, from]

    // Jump to do safe check if the caller is a contract
    isContract                               // jump is sender 
    jumpi                           // [to, to, from]

    // check for zero address, if sent to the zero address revert, otherwise fin
    iszero                          // [!to, to, from]
    error jumpi                     // [to, from]
    continue jump                   // [to, from]

    isContract:
    // make external call to contract
    // get data
    
    // get value
    

    0xf23a6e61 0xE0 shl             // [selector]
    dup1 0x20 mstore                // [selector, selector]

    0x04 calldatasize sub           // [(cds-4), ]
    0x04
    0x44
    calldatacopy
        
    
    // store caller in first calldata slot
    caller 0x24 mstore              // [selector, to, from]

    // store from in the second
    dup3 0x44 mstore                // [selector, to, from]]
    
    // update location of the bytes calldata
    0xa0 0xa4  mstore

    // clear return space in preparation for the call
    0x00 0x00 mstore                // [selector, to, from]

    // call
    0x20                            // [retSize, selector, to]                                                   retSize: 0x04
    0x00                            // [retOffset, retSize, selector, to]                                        retOffset: 0x00
    calldatasize 0x20 add           // [argSize, retOffset, retSize, selector, to]                               argSize: calldatasize + 20 // we add one more address into the mix
    0x20                            // [argOffset, argSize, retOffset, retSize, selector, to]                    argOffset: 0x20            // read the args from 0x20
    0x00                            // [value, argOffset, argSize, retOffset, retSize, selector, to]             value: 0x00                // send no ether
    dup7                            // [to, value, argOffset, argSize, retOffset, retSize, selector, to]         to: to                     // send to the to address
    gas                             // [gas, to, value, argOffset, argSize, retOffset, retSize, selector, to]    gas: gas                   // forward all gas    
    call                            // [success, selector, to]                                                   call 


    iszero error jumpi

    // read response
    0x00 mload 0xE0 shr             // [response]
    0xf23a6e61 
    eq 
    iszero
    error 
    jumpi
    
    continue:
    stop

    error:
        0x00 dup1 revert
}
 


// _burn(address from,uint256 id,uint256 amount
#define macro BURN_TOKEN() = takes(0) returns(0){
    0x44 calldataload               // [amount]
    0x24 calldataload               // [tokenId, amount]
    dup2 dup2                       // [tokenId, amount, tokenId, amount]
    0x04 calldataload               // [from, tokenId, amount]

    DECREASE_BALANCE()              // [tokenId, amount]
    
    // Emit transfer log
    0x00 mstore                     // store tokenId in memory for log
    0x20 mstore                     // store amount in memory for log           

    0x00                            // [zero_address]
    0x04 calldataload               // [from, zero_address]
    caller                          // [msg.sender, from,zero_address]
    [TRANSFER_SINGLE_SIGNATURE]     // [TransferSingle, msg.sender,from, zero_address] 
    0x00 0x40                       // log data
    log4

    stop
}

// TODO: over haul this entire thing and use memory, and log
#define macro BATCH_MINT() = takes(0) returns(0){

    // get length of arrays
    0x00                            // push 0x00 onto the stack for use as the from field in logging
    0x04 calldataload               // [to]

    // get length of the ids array - stash arr pointers at end of stack
    0x44 calldataload 0x4 add dup1  // [&amount, &amount, to]
    0x24 calldataload 0x4 add dup1  // [&ids, &ids, &amount, &amount, to] 
    swap2                           // [&amount, &ids, &amount, &amount, to]
    calldataload swap1              // [&ids, amounts.length, &amount, &ids, to] 
    calldataload dup1               // [ids.length, ids.length, amounts.length, &amount, &ids, to ]
    swap2                           // [amounts.len, ids.len, ids.len, &amount, &ids, to]

    eq isTrue                       // [amounts.length == ids.length, ids.len, &amount, &ids, to]
    jumpi                           // [ids.len, &amount, &ids, to]
    0x00 dup1 revert

    isTrue:

        // loop over the arrays of ids and amounts and increase the balance
    0x00    // [i, ids.length, &amount, &ids, to]
    loop:
        dup2 dup2           //[i, ids.length, i, ids.length, &amount, &ids, to]
        eq exit jumpi       // [i, ids.length, &amount, &ids, to]


        // takes: to, tokenId, amount
        swap2               // [&amount, ids.length, i,  &ids, to]
        0x20 add            // [&amount+32, ids.len, i,  &ids, to]
        dup1                // [&amount+32, &amount+32, ids.len, i, &ids, to]
        swap3               // [i, &amount+32, ids.len, &amount+32, &ids, to]
        swap1               // [&amount+32, i, ids.len, &amount+32, &ids, to]
        calldataload        // [amount[0], i, ids.len, &amount+32, &ids, to]

        swap1               // [i, amount[0], ids.len, &amount+32, &ids, to]
        swap4               // [&ids, amount[0], ids.len, &amount+32, i, to]
        0x20 add            // [&ids+32, amount[0], ids.len, &amount+32, i, to]
        dup1                // [&ids+32, &ids+32, amount[0], ids.len, &amount+32, i, to]
        swap5 swap1         // [&ids+32, i, amount[0], ids.len, &amount+32, &ids+32, to]               
        calldataload        // [ids[0], i, amount[0], ids.len, &amount+32, &ids+32, to]

        swap1 swap2         // [ ids[0], amount[0], i,  ids.len, &amount+32, &ids+32, to]
        
        0x04 calldataload   // [to, ids[0], amount[0], i,  ids.len, &amount+32, &ids+32, to]   
        INCREASE_BALANCE()  // [i, ids.len, &amount+32, &ids+32, to]

        0x01 add
                            // [ i,  ids.len, &amount+32, &ids+32, to]
    loop jump
    
    exit:

    dup4 0x20 add
    0x84

    EMIT_BATCH_LOG()
    pop pop

    0x24
    dup7
    dup7

    SAFE_BATCH()
}


// TODO: stack counting in this is completely wrong
#define macro EMIT_BATCH_LOG() = takes(4) returns(0) {
    // takes:                       // [&ids, &data, to, from]
    dup1                            // [&ids, &ids, &data, to, from]
    swap2                           // [&data. &ids, &ids, to, from]
    sub                             // [len(ids, amounts), &ids, to, from]
    dup1                            // [len(ids, amounts), len(ids, amounts), &ids, to, from]

    dup3                            // [&ids, len(ids, amounts), len(ids, amounts), &ids, to, from]]         
    0x60                            // [0x60, &ids, len(ids, amounts), len(ids, amounts), &ids, to, from]]   // offset, &ids
    calldatacopy                    // [len(ids, amounts), &ids, to, from]

    // store the pointers to the ids and amounts in memory
    0x40 0x20 mstore                // [len(ids, amounts), &ids, to, from 
    0x40 0x20 dup5 dup2 mul add add 0x40 mstore  //  

    dup8                            // [to, len(ids, amounts)]
    dup8                            // [from, to, len(ids, amounts)]
    caller                          // [caller, from, to, len(ids, amounts)]
    [TRANSFER_BATCH_SIGNATURE]
    dup5 0x40 add                   // [len(ids, amounts), caller, from, to, len(ids, amounts)]
    0x20                            // [offset, len(ids, amounts), caller, from, to, len(ids, amounts)]
    log4
}

#define macro SAFE_BATCH() = takes(2) returns(0) {
    // to, from


    // If being sent by a contract then do contract code check, no need to check for zero address and contract as it would not have code
    dup1 extcodesize iszero iszero  // [!(codesize(to)), to from, &ids]
    isContract jumpi                // [to, from, &ids]

    // check is sending to the zero address, if so revert, otherwise continue
    iszero                          // [iszero(to), from, &ids]
    error jumpi                     // error if address is zero
    continue jump                   // continue to end and stop if complete

    // Note: to has not been popped off here as we skip the zero check above
    isContract:                     // [to, from, &ids]

    // place calldatasize on the stack <- used when sending calldata to a contract
    calldatasize                    // [cds, to, from, &ids]

    // store selctor in memory for comparison later
    0xbc197c81 0xE0 shl             // [selector, cds, to, from, &ids]
    dup1 0x20 mstore                // [selector, cds, to, from, &ids]

    // TODO: DOCUMENT THIS
    // Store ENTIRE calldata in memory for batch call 
    dup5 dup3 sub                   // [(cds-4), cds, to, from, &ids]   // sub4 to not overwrite the new selctor
    dup6                            // [&ids, (cds-4), cds, to, from, &ids]
    0x64                            // [0x64, &ids, (cds-4), cds, to, from, &ids]
    calldatacopy                    // [selector, cds, to, from]

    caller 0x24 mstore              // [selector, cds, to, from]

    dup4 0x44 mstore                // [selector, cds, to, from]

    // We can skip this rezise if we are transferring as we can assume the offsets are in the corrrect places, due to the increased address input parameter
    // We can tell if we are transferring as the from parameter on the stack will NOT be zero
    // TODO ^ document this optimisation
    dup4 iszero iszero skipResize jumpi

    // increase the dyn pointer balances by 0x20 for each dynamic type, this is due to the introduction of the from value in the call
    0x20                                    // [0x20, selector, cds, to, from, &ids]
    0x64 dup1 mload dup3 add swap1 mstore                          
    0x84 dup1 mload dup3 add swap1 mstore  
    0xa4 dup1 mload dup3 add swap1 mstore
                                            // [0x20, selector, cds, to, from, &ids]

    // increase calldatasize value by 0x20, when minting 
    swap1                                   // [selector, 0x20, cds, to, from, &ids]
    swap2                                   // [cds, 0x20, selector, to, from, &ids]
    add                                     // [0x20 + cds, selector, to, from, &ids]
    swap1                                   // [selector, 0x20 + cds, to, from, &ids]

    skipResize:

    // clear return memory space (using scratch space)
    0x00 dup1 mstore

    // call
    0x20                            // [retSize, selector, to]                                                   retSize: 0x04
    0x00                            // [retOffset, retSize, selector, to]                                        retOffset: 0x00
    dup4                            // [argSize, retOffset, retSize, selector, to]                               argSize: calldatasize (?+ 20) // increased by 20 if we are minting as cds will be increased, if it is a batch transfer then it will not
    0x20                            // [argOffset, argSize, retOffset, retSize, selector, to]                    argOffset: 0x20            // read the args from 0x20
    0x00                            // [value, argOffset, argSize, retOffset, retSize, selector, to]             value: 0x00                // send no ether
    dup8                            // [to, value, argOffset, argSize, retOffset, retSize, selector, to]         to: to                     // send to the to address
    gas                             // [gas, to, value, argOffset, argSize, retOffset, retSize, selector, to]    gas: gas                   // forward all gas    
    call                            // [success, selector, to]                                                   call 

    iszero error jumpi

    // read response - ensure that the function call returns the expected selector
    0x00 mload 0xE0 shr             // [response]
    0xbc197c81 
    eq 
    iszero
    error 
    jumpi


    continue:
        stop

    error:
        0x00 dup1 revert
}


#define macro BATCH_BURN() = takes(0) returns(0) {
    // get length of arrays
    0x04 calldataload               // [from]
    0x00                            // [to, from]

    // get length of the ids array - stash arr pointers at end of stack
    0x44 calldataload 0x4 add dup1  // [&amount, &amount, to, to, from]
    0x24 calldataload 0x4 add dup1  // [&ids, &ids, &amount, &amount, to, from] 
    swap2                           // [&amount, &ids, &amount, &amount, to, from]
    calldataload swap1              // [&ids, amounts.length, &amount, &ids, to, from] 
    calldataload dup1               // [ids.length, ids.length, amounts.length, &amount, &ids, to, from] ]
    swap2                           // [amounts.len, ids.len, ids.len, &amount, &ids, to, from]

    eq isTrue                       // [amounts.length == ids.length, ids.len, &amount, &ids, to, from]
    jumpi                           // [ids.len, &amount, &ids, to, from]
    0x00 dup1 revert

    isTrue:

    // loop over the arrays of ids and amounts and increase the balance
    0x00    // [i, ids.length, &amount, &ids, to, from]
    loop:
        dup2 dup2           //[i, ids.length, i, ids.length, &amount, &ids, to, from]
        eq exit jumpi       // [i, ids.length, &amount, &ids, to, from]


        // takes: to, tokenId, amount
        swap2               // [&amount, ids.length, i,  &ids, to, from]
        0x20 add            // [&amount+32, ids.len, i,  &ids, to, from]
        dup1                // [&amount+32, &amount+32, ids.len, i, &ids, to, from]
        swap3               // [i, &amount+32, ids.len, &amount+32, &ids, to, from]
        swap1               // [&amount+32, i, ids.len, &amount+32, &ids, to, from]
        calldataload        // [amount[0], i, ids.len, &amount+32, &ids, to, from]

        swap1               // [i, amount[0], ids.len, &amount+32, &ids, to, from]
        swap4               // [&ids, amount[0], ids.len, &amount+32, i, to, from]
        0x20 add            // [&ids+32, amount[0], ids.len, &amount+32, i, to, from]
        dup1                // [&ids+32, &ids+32, amount[0], ids.len, &amount+32, i, to, from]
        swap5 swap1         // [&ids+32, i, amount[0], ids.len, &amount+32, &ids+32, to, from]               
        calldataload        // [ids[0], i, amount[0], ids.len, &amount+32, &ids+32, to, from]

        swap1 swap2         // [ ids[0], amount[0], i,  ids.len, &amount+32, &ids+32, to, from]
        
        dup8                // [from, ids[0], amount[0], i,  ids.len, &amount+32, &ids+32, to, from]   
        DECREASE_BALANCE()  // [i, ids.len, &amount+32, &ids+32, to, from]

        0x01 add
                            // [ i,  ids.len, &amount+32, &ids+32, to, from]
    loop jump
    
    exit:

    dup4 0x20 add
    0x84

    EMIT_BATCH_LOG()
    stop
}

#define macro BATCH_SAFE_TRANSFER_FROM() = takes(0) returns(0) {
    
    // check lengths
    0x04 calldataload               // [from]
    0x24 calldataload               // [to, from]

    // get length of the ids array - stash arr pointers at end of stack
    0x64 calldataload 0x4 add dup1  // [&amount, &amount, to, from]
    0x44 calldataload 0x4 add dup1  // [&ids, &ids, &amount, &amount, to, from] 
    swap2                           // [&amount, &ids, &amount, &amount, to, from]
    calldataload swap1              // [&ids, amounts.length, &amount, &ids, to, from] 
    calldataload dup1               // [ids.length, ids.length, amounts.length, &amount, &ids, to, from ]
    swap2                           // [amounts.len, ids.len, ids.len, &amount, &ids, to, from]

    eq isTrue jumpi                 // [amounts.length == ids.length, ids.len, &amount, &ids, to, from]
    error jumpi                     // [ids.len, &amount, &ids,to, from]

    // check approvals
    IS_OWNER_OR_APPROVED(error)

    // perform batch transfers
    isTrue:

    // loop over the arrays of ids and amounts and increase the balance
    0x00    // [i, ids.length, &amount, &ids, from]
    loop:
        dup2 dup2           //[i, ids.length, i, ids.length, &amount, &ids, to, from]
        eq exit jumpi       // [i, ids.length, &amount, &ids, from]


        // takes: to, tokenId, amount
        swap2               // [&amount, ids.length, i,  &ids, to, from]
        0x20 add            // [&amount+32, ids.len, i,  &ids, to, from]
        dup1                // [&amount+32, &amount+32, ids.len, i, &ids, to, from]
        swap3               // [i, &amount+32, ids.len, &amount+32, &ids, to, from]
        swap1               // [&amount+32, i, ids.len, &amount+32, &ids, to, from]
        calldataload        // [amount[0], i, ids.len, &amount+32, &ids, to, from]

        swap1               // [i, amount[0], ids.len, &amount+32, &ids, to, from]
        swap4               // [&ids, amount[0], ids.len, &amount+32, i, to, from]
        0x20 add            // [&ids+32, amount[0], ids.len, &amount+32, i, to, from]
        dup1                // [&ids+32, &ids+32, amount[0], ids.len, &amount+32, i, to, from]
        swap5 swap1         // [&ids+32, i, amount[0], ids.len, &amount+32, &ids+32, to, from]               
        calldataload        // [ids[0], i, amount[0], ids.len, &amount+32, &ids+32, to, from]

        swap1 swap2         // [ ids[0], amount[0], i,  ids.len, &amount+32, &ids+32, to, from]
        
        dup7                // [to, ids[0], amount[0], i,  ids.len, &amount+32, &ids+32, to, from]   
        dup3 dup3           // [ids[0], amount[0], to, ids[0], amount[0], i,  ids.len, &amount+32, &ids+32, to, from]
        dup11               // [from, ids[0], amount[0], to, ids[0], amount[0], i,  ids.len, &amount+32, &ids+32, to, from]
        DECREASE_BALANCE()  // [to, ids[0], amount[0], i,  ids.len, &amount+32, &ids+32, to, from]
        INCREASE_BALANCE()  // [i,  ids.len, &amount+32, &ids+32, to, from ]

        0x01 add
                            // [ i,  ids.len, &amount+32, &ids+32, to, from]
    loop jump
    
    exit:
        
    // EMIT BATCH TRANSFER LOG
    
    // [&ids, &amounts[-1], to, from]
    dup4 0x20 add                  // [&data, i,  ids.len, &amount+32, &ids+32, amounts[0], to, from]
    0xa4                           // [&ids, &data, i,  ids.len, &amount+32, &ids+32, to, from] 
    
    // takes:                      // [&ids, &data, to, from]
    // TODO: exit stack is wrong
    EMIT_BATCH_LOG()               // [&ids, i, ids.len, &amount+32, &ids+32, to, from]
    pop pop
    
    // SAFE_TRANSFER_LOGIC
    // Get the location of the start of the ids dynamic data
    0x44                           // [dyn(ids)]
    dup7                           // [from, dyn(ids)]
    dup7                            //[to, from, dyn(ids)]

    // takes: [to, from, dyn(ids)]   
    SAFE_BATCH()
}



#define macro SUPPORTS_INTERFACE() = takes(0) returns(0) {
    0x04 calldataload
    dup1 0x01ffc9a7 eq isTrue jumpi
    dup1 0xd9b67a26 eq isTrue jumpi
    dup1 0x0e89341c eq isTrue jumpi

    0x00 0x00 mstore ret jump 

    isTrue:
        0x01 0x00 mstore

    ret:
        0x00 0x20 return
}


/* Main */
#define macro MAIN() = takes(0) returns(0) {
    0x00 calldataload 0xE0 shr      // [function selector on stack]
    
    dup1 __FUNC_SIG(mint) eq mint jumpi //__FUNC_SIG(mint)
    dup1 __FUNC_SIG(safeTransferFrom) eq safeTransferFrom jumpi
    dup1 __FUNC_SIG(safeBatchTransferFrom) eq batchSafeTransferFrom jumpi
    dup1 __FUNC_SIG(setApprovalForAll) eq setApprovalForAll jumpi
    dup1 __FUNC_SIG(batchMint) eq batchMint jumpi 
    dup1 __FUNC_SIG(balanceOf) eq balanceOf jumpi 
    dup1 __FUNC_SIG(burn) eq burn jumpi
    dup1 __FUNC_SIG(batchBurn) eq batchBurn jumpi
    dup1 __FUNC_SIG(name) eq name jumpi
    dup1 __FUNC_SIG(symbol) eq symbol jumpi
    dup1 __FUNC_SIG(supportsInterface) eq getName jumpi
    dup1 __FUNC_SIG(isApprovedForAll) eq isApprovedForAll jumpi
    dup1 __FUNC_SIG(symbol) eq symbol jumpi
    dup1 __FUNC_SIG(getName) eq getName jumpi

    // No fallback function
    0x00 dup1 revert

    supportsInterface:
        SUPPORTS_INTERFACE()
    getName:
        NAME()
    mint:
        MINT()
    balanceOf:
        BALANCE_OF()
    safeTransferFrom:
        SAFE_TRANSFER_FROM()
    batchSafeTransferFrom:
        BATCH_SAFE_TRANSFER_FROM()
    burn:
        BURN_TOKEN()
    batchMint:
        BATCH_MINT()
    name:
        NAME()
    symbol:
        SYMBOL()
    isApprovedForAll:
        IS_APPROVED_FOR_ALL()
    setApprovalForAll:
        SET_APPROVAL_FOR_ALL()
    batchBurn:
        BATCH_BURN()

}
