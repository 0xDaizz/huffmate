/// @title ERC4626
/// @author asnared <https://github.com/abigger87>
/// @notice Minimal ERC4626 tokenized Vault implementation.
/// @notice Adapted from Solmate (https://github.com/transmissions11/solmate/blob/main/src/mixins/ERC4626.sol)

// ERC4626 is ERC20
#include "./ERC20.huff"
#include "../math/FixedPointMath.huff"

// Events
#define event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares)
#define event Withdraw(address indexed caller, address indexed receiver, address indexed owner, uint256 assets, uint256 shares)

// Interface
#define function asset() view returns (address)


// TODO: Grab dynamic constructor args

// Storage
#define constant ASSET_SLOT = FREE_STORAGE_POINTER()

#define constant TYPE_UINT_256_MAX = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff

/// @notice Constructor
#define macro INNER_4626_CONSTRUCTOR() = takes (0) returns (0) {
    // Copy the asset address into memory and then the stack from the bytecode
    0x20                    // [size] - byte size to copy
    0x20 codesize sub       // [offset, size] - offset in the code to copy from
    0x00                    // [mem, offset, size] - offset in memory to copy to
    codecopy                // []
    0x00 mload              // [asset]

    // Store the decimals function selector in memory to call
    __FUNC_SIG(decimals)    // [sig_right_padded, asset]
    0xE0 shl                // [sig_left_padded, asset]
    0x20 mstore             // [asset]

    // Call the asset to get its decimals
    0x20                    // [retSize, asset]
    0x00                    // [retOffset, retSize, asset]
    0x04                    // [argSize, retOffset, retSize, asset]
    0x20                    // [argOffset, argSize, retOffset, retSize, asset]
    dup5                    // [to, argOffset, argSize, retOffset, retSize, asset]
    gas                     // [gas, to, argOffset, argSize, retOffset, retSize, asset]
    staticcall              // [success, asset]

    // If the call failed, revert
    iszero iszero           // [success, asset]
    cont jumpi              // [asset]
    0x00 dup1 revert        // []
    cont:

    // Store the decimals
    0x00 mload              // [decimals, asset]
    [DECIMALS_SLOT] sstore  // [asset]

    // Store the asset
    [ASSET_SLOT] sstore     // []

    // Configure the initial domain separator
    chainid [INITIAL_CHAIN_ID] sstore       // []
    COMPUTE_DOMAIN_SEPARATOR()              // [DOMAIN SEPARATOR]
    [INITIAL_DOMAIN_SEPARATOR] sstore       // []

    // TODO: here is where we should set the name + symbol storage variables

    // Allow execution to continue for parent construction
}

/// @notice Returns the ERC4626 decimals
#define macro ERC4626_DECIMALS() = takes (0) returns (0) {
    [DECIMALS_SLOT] sload
    0x00 mstore
    0x20 0x00 return
}

/// @notice Returns the ERC4626 asset
#define macro ERC4626_ASSET() = takes (0) returns (0) {
    [ASSET_SLOT] sload
    0x00 mstore
    0x20 0x00 return
}

// ------------------------------------------------------
// DEPOSIT/WITHDRAWAL LOGIC
// ------------------------------------------------------


/// @notice Mint
/// @notice Mints a {receiver} x amount of {assets} proportional to the input {shares}
/// @param shares The amount of shares to mint
#define macro MINT() = takes (0) returns (0) {
    0x24 calldataload       // [receiver]
    0x04 calldataload       // [shares, receiver]
    MINT_INNER()            // [assets]
    0x00 mstore             // []
    0x20 0x00 return        // []
}

/// @notice Mint Internal Helper
#define macro MINT_INNER() = takes (2) returns (1) {
    // Input stack: [shares, receiver]
    // Output stack: [assets]

    // Preview the mint given the number of shares
    dup1                    // [shares, shares, receiver]
    PREVIEW_MINT_INNER()    // [assets, shares, receiver]

    // Transfer the assets from the caller to the vault

    // Store the safeTransferFrom selector in memory
    __FUNC_SIG(safeTransferFrom)    // [selector, assets, shares, receiver]
    0xE0 shl                        // [selector, assets, shares, receiver]
    0x00 mstore                     // [assets, shares, receiver]

    // Store the caller in memory as the first arg
    caller 0x04 mstore              // [assets, shares, receiver]

    // Store this address as the second call argument in memory
    address 0x24 mstore             // [assets, shares, receiver]

    // Store assets as the third call argument in memory
    dup1 0x44 mstore                // [assets, shares, receiver]

    // Load the asset as the call destination
    [ASSET_SLOT] sload              // [asset, assets, shares, receiver]

    // Construct the call
    0x00                            // [retSize, asset, assets, shares, receiver]
    0x00                            // [retOffset, retSize, asset, assets, shares, receiver]
    0x64                            // [argSize, retOffset, retSize, asset, assets, shares, receiver]
    0x00                            // [argOffset, argSize, retOffset, retSize, asset, assets, shares, receiver]
    0x00                            // [value, argOffset, argSize, retOffset, retSize, asset, assets, shares, receiver]
    dup6                            // [to, value, argOffset, argSize, retOffset, retSize, asset, assets, shares, receiver]
    gas                             // [gas, to, value, argOffset, argSize, retOffset, retSize, asset, assets, shares, receiver]
    call                            // [success, asset, assets, shares, receiver]

    // Verify the call succeeded
    iszero iszero success jumpi     // [asset, assets, shares, receiver]
    0x00 dup1 revert                // []
    success:

    // Mint vault shares to the receiver
    pop                             // [assets, shares, receiver]
    dup3 dup3                       // [shares, receiver, assets, shares, receiver]
    _MINT()                         // [assets, shares, receiver]

    // Emit the deposit event
    dup1 0x00 mstore                // [assets, shares, receiver]
    dup2 0x20 mstore                // [assets, shares, receiver]
    dup3 caller                     // [msg.sender, receiver, assets, shares, receiver]
    __EVENT_HASH(Deposit)           // [event_hash, msg.sender, receiver, assets, shares, receiver]
    0x40 0x00 log3                  // [assets, shares, receiver]

    // Call the after deposit hook
    swap1 dup2                      // [assets, shares, assets, receiver]
    AFTER_DEPOSIT()                 // [assets, receiver]

    // Return just the assets
    swap1 pop                       // [assets]
}

// TODO: redeem
// function redeem(
//     uint256 shares,
//     address receiver,
//     address owner
// ) public virtual returns (uint256 assets) {
//     if (msg.sender != owner) {
//         uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.

//         if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;
//     }

//     // Check for rounding error since we round down in previewRedeem.
//     require((assets = previewRedeem(shares)) != 0, "ZERO_ASSETS");

//     beforeWithdraw(assets, shares);

//     _burn(owner, shares);

//     emit Withdraw(msg.sender, receiver, owner, assets, shares);

//     asset.safeTransfer(receiver, assets);
// }


/// @notice Deposit assets into the ERC4626 Vault
#define macro DEPOSIT_INNER() = takes (2) returns (1) {
    // Input stack: [assets, receiver]
    // Output stack: [shares]

    // Validate that the assets shares are not zero
    dup1                            // [assets, assets, receiver]
    PREVIEW_DEPOSITS_INNER()        // [shares, assets, receiver]
    dup1 iszero iszero cont jumpi   // [shares, assets, receiver]
    ZERO_SHARES(0x00)
    cont:

    // Store the safeTransferFrom selector in memory
    __FUNC_SIG(safeTransferFrom)    // [selector, shares, assets, receiver]
    0xE0 shl                        // [selector, shares, assets, receiver]
    0x00 mstore                     // [shares, assets, receiver]

    // Store the caller in memory as the first arg
    caller 0x04 mstore              // [shares, assets, receiver]

    // Store this address as the second call argument in memory
    address 0x24 mstore             // [shares, assets, receiver]

    // Store assets as the third call argument in memory
    dup1 0x44 mstore                // [shares, assets, receiver]

    // Construct the call
    0x00                            // [retSize, shares, assets, receiver]
    0x00                            // [retOffset, retSize, shares, assets, receiver]
    0x64                            // [argSize, retOffset, retSize, shares, assets, receiver]
    0x00                            // [argOffset, argSize, retOffset, retSize, shares, assets, receiver]
    0x00                            // [value, argOffset, argSize, retOffset, retSize, shares, assets, receiver]
    dup7                            // [to, value, argOffset, argSize, retOffset, retSize, shares, assets, receiver]
    gas                             // [gas, to, value, argOffset, argSize, retOffset, retSize, shares, assets, receiver]
    call                            // [success, shares, assets, receiver]

    // Verify the call succeeded
    iszero iszero success jumpi     // [shares, assets, receiver]
    0x00 dup1 revert                // []
    success:

    // Mint to the receiver
    dup3 dup2                       // [shares, receiver, shares, assets, receiver]
    _MINT()                         // [shares, assets, receiver]

    // Emit the Deposit Event
    dup2 0x00 mstore                // [shares, assets, receiver]
    dup1 0x20 mstore                // [shares, assets, receiver]
    dup3 caller                     // [msg.sender, receiver, shares, assets, receiver]
    __EVENT_HASH(Deposit)           // [event_hash, msg.sender, receiver, shares, assets, receiver]
    0x40 0x00 log3                  // [shares, assets, receiver]

    // Call the after deposit hook
    dup1 swap2 swap1                // [shares, assets, shares, receiver]
    AFTER_DEPOSIT()                 // [shares, receiver]

    // Return the shares
    swap1 pop                       // [shares]
}

/// @notice Withdraws assets from an ERC4626 Vault
#define macro WITHDRAWAL_INNER() = takes (3) returns (1) {
    // Input stack: [assets, receiver, owner]
    // Output stack: [shares]

    // Get the shares from the assets
    dup1 PREVIEW_WITHDRAW_INNER()       // [shares, assets, receiver, owner]

    // Skip ahead if msg.sender is the owner
    dup4 caller eq sender jumpi         // [shares, assets, receiver, owner]

    // Get the allowance[owner][msg.sender]
    caller dup5                         // [owner, msg.sender, shares, assets, receiver, owner]
    [APPROVAL_SLOT]                     // [slot, owner, msg.sender, shares, assets, receiver, owner]
    LOAD_ELEMENT_FROM_KEYS_2D(0x00)     // [allowance, shares, assets, receiver, owner]

    // If the allowed is no infinite approval, set to the allowance less shares
    dup1 [TYPE_UINT_256_MAX]            // [type(uint256).max, allowance, allowance, shares, assets, receiver, owner]
    eq infinite jumpi                   // [allowance, shares, assets, receiver, owner]

    // Set the new allowance
    dup2 dup2 sub                       // [new_allowance, allowance, shares, assets, receiver, owner]
    caller dup6 [APPROVAL_SLOT]         // [slot, owner, msg.sender, new_allowance, allowance, shares, assets, receiver, owner]
    STORE_ELEMENT_FROM_KEYS_2D(0x00)    // [allowance, shares, assets, receiver, owner]

    infinite:

    sender:

    // Call the before withdrawal hook
    dup2 dup4                           // [assets, shares, allowance, shares, assets, receiver, owner]
    BEFORE_WITHDRAW()                   // [allowance, shares, assets, receiver, owner]

    // Burn the shares
    dup2 dup6                           // [owner, shares, allowance, shares, assets, receiver, owner]
    _BURN()                             // [allowance, shares, assets, receiver, owner]

    // Emit the Withdraw Event
    dup3 0x00 mstore                // [allowance, shares, assets, receiver, owner]
    dup2 0x20 mstore                // [allowance, shares, assets, receiver, owner]
    dup5 dup4 caller                // [msg.sender, assets, owner, allowance, shares, assets, receiver, owner]
    __EVENT_HASH(Withdraw)          // [event_hash, msg.sender, assets, owner, allowance, shares, assets, receiver, owner]
    0x40 0x00 log4                  // [allowance, shares, assets, receiver, owner]

    // Store the safeTransfer selector in memory
    __FUNC_SIG(safeTransfer)        // [selector, allowance, shares, assets, receiver, owner]
    0xE0 shl                        // [selector, allowance, shares, assets, receiver, owner]
    0x00 mstore                     // [allowance, shares, assets, receiver, owner]

    // Store the receiver in memory as the first arg
    dup4 0x04 mstore                // [allowance, shares, assets, receiver, owner]

    // Store this address as the second call argument in memory
    dup3 0x24 mstore                // [allowance, shares, assets, receiver, owner]

    // Load asset from storage
    [ASSET_SLOT] sload              // [asset, allowance, shares, assets, receiver, owner]

    // Construct the call
    0x00                            // [retSize, asset, allowance, shares, assets, receiver, owner]
    0x00                            // [retOffset, retSize, asset, allowance, shares, assets, receiver, owner]
    0x44                            // [argSize, retOffset, retSize, asset, allowance, shares, assets, receiver, owner]
    0x00                            // [argOffset, argSize, retOffset, retSize, asset, allowance, shares, assets, receiver, owner]
    0x00                            // [value, argOffset, argSize, retOffset, retSize, asset, allowance, shares, assets, receiver, owner]
    dup6                            // [to, value, argOffset, argSize, retOffset, retSize, asset, allowance, shares, assets, receiver, owner]
    gas                             // [gas, to, value, argOffset, argSize, retOffset, retSize, asset, allowance, shares, assets, receiver, owner]
    call                            // [success, asset, allowance, shares, assets, receiver, owner]

    // Verify the call succeeded
    iszero iszero success jumpi     // [asset, allowance, shares, assets, receiver, owner]
    0x00 dup1 revert                // []
    success:

    // Return shares
    pop pop                         // [shares, assets, receiver, owner]
    swap3 pop pop pop               // [shares]
}


// ------------------------------------------------------
// ACCOUNTING LOGIC
// ------------------------------------------------------

#define macro TOTAL_ASSETS() = takes (0) returns (1) {
    // Input Stack: []
    // Output Stack: [total_assets]

    // TODO: OVERRIDE
}

/// @notice Returns the amount of assets needed to mint the given amount of shares
#define macro PREVIEW_MINT() = takes (0) returns (0) {
    0x04 calldataload                   // [shares]
    PREVIEW_MINT_INNER()                // [assets]
    0x00 mstore                         // []
    0x20 0x00 return                    // []
}

#define macro PREVIEW_MINT_INNER() = takes (1) returns (1) {
    // Input Stack: [shares]
    // Output Stack: [assets]

    // Load the total supply
    [TOTAL_SUPPLY_SLOT] sload               // [supply, shares]

    // Return shares if supply is zero
    dup1 iszero iszero calculate jumpi      // [supply, shares]
    pop cont jump                           // []

    // Otherwise mul div up
    calculate:

    swap1                                   // [shares, supply]
    TOTAL_ASSETS() swap1                    // [shares, total_assets, supply]
    MUL_DIV_UP(fail)                        // [shares]
    cont jump

    // Fail with an arithmetic overflow
    fail:
    [ARITHMETIC_OVERFLOW] PANIC()

    // Resume withdrawal with share count
    cont:                                   // [assets]
}

/// @notice Calculates the amount of shares that would be exchanged for a given amount of assets
#define macro PREVIEW_DEPOSITS() = takes (1) returns (1) {
    0x04 calldataload               // [assets]
    PREVIEW_DEPOSITS_INNER()        // [shares]
    0x00 mstore                     // []
    0x20 0x00 return                // []
}

#define macro PREVIEW_DEPOSITS_INNER() = takes (1) returns (1) {
    CONVERT_TO_SHARES_INNER()       // [shares]
}

/// @notice Converts assets to shares
#define macro CONVERT_TO_SHARES() = takes (0) returns (0) {
    0x04 calldataload               // [assets]
    CONVERT_TO_SHARES_INNER()       // [shares]
    0x00 mstore                     // []
    0x20 0x00 return                // []
}

#define macro CONVERT_TO_SHARES_INNER() = takes (1) returns (1) {
    // Input Stack: [assets]
    // Output Stack: [shares]

    [TOTAL_SUPPLY_SLOT] sload               // [supply, assets]

    // Return assets if supply is zero
    dup1 iszero iszero calculate jumpi      // [supply, assets]
    pop cont jump                           // []

    // Otherwise mul div down
    calculate:

    TOTAL_ASSETS() swap2                    // [assets, supply, total_assets]
    MUL_DIV_DOWN(fail)                      // [shares]
    cont jump

    // Fail with an arithmetic overflow
    fail:
    [ARITHMETIC_OVERFLOW] PANIC()

    // Resume withdrawal with share count
    cont:                                   // [shares]
}

/// @notice Converts shares to assets
#define macro CONVERT_TO_ASSETS() = takes (0) returns (0) {
    0x04 calldataload               // [shares]
    CONVERT_TO_ASSETS_INNER()       // [assets]
    0x00 mstore                     // []
    0x20 0x00 return                // []
}

#define macro CONVERT_TO_ASSETS_INNER() = takes (1) returns (1) {
    // Input Stack: [shares]
    // Output Stack: [assets]

    [TOTAL_SUPPLY_SLOT] sload               // [supply, shares]

    // Return assets if supply is zero
    dup1 iszero iszero calculate jumpi      // [supply, shares]
    pop cont jump                           // []

    // Otherwise mul div down
    calculate:

    swap1                                   // [shares, supply]
    TOTAL_ASSETS() swap1                    // [shares, total_assets, supply]
    MUL_DIV_DOWN(fail)                      // [assets]
    cont jump

    // Fail with an arithmetic overflow
    fail:
    [ARITHMETIC_OVERFLOW] PANIC()

    // Resume withdrawal with share count
    cont:                                   // [assets]
}

#define macro PREVIEW_WITHDRAW_INNER() = takes (1) returns (1) {
    // Input Stack: [assets]
    // Output Stack: [shares]

    [TOTAL_SUPPLY_SLOT] sload               // [supply, assets]

    // Return assets if supply is zero
    dup1 iszero iszero calculate jumpi      // [supply, assets]
    pop cont jump                           // []

    // Otherwise mul div up
    calculate:

    TOTAL_ASSETS() swap2                    // [assets, supply, total_assets]
    MUL_DIV_UP(fail)                        // [shares]
    cont jump

    // Fail with an arithmetic overflow
    fail:
    [ARITHMETIC_OVERFLOW] PANIC()

    // Resume withdrawal with share count
    cont:                                   // [shares]
}

/// @notice Calculates the amount of assets that would be exchanged for a given amount of shares on redemption
#define macro PREVIEW_REDEEM() = takes (0) returns (0) {
    0x04 calldataload               // [shares]
    CONVERT_TO_ASSETS_INNER()       // [assets]
    0x00 mstore                     // []
    0x20 0x00 return                // []
}

// ------------------------------------------------------
// DEPOSIT/WITHDRAWAL LIMIT LOGIC
// ------------------------------------------------------

#define macro MAX_DEPOSIT() = takes (0) returns (0) {
    [TYPE_UINT_256_MAX]             // [type(uint256).max]
    0x00 mstore                     // []
    0x20 0x00 return                // []
}

#define macro MAX_MINT() = takes (0) returns (0) {
    [TYPE_UINT_256_MAX]             // [type(uint256).max]
    0x00 mstore                     // []
    0x20 0x00 return                // []
}

/// @notice Max Withdraw
/// @notice Returns the maximum amount of assets available to withdraw
#define macro MAX_WITHDRAW() = takes (0) returns (0) {
    0x04 calldataload               // [owner]
    [BALANCE_OF_SLOT] sload         // [balanceOf[owner]]
    CONVERT_TO_ASSETS_INNER()       // [assets]
    0x00 mstore                     // []
    0x20 0x00 return                // []
}

/// @notice Max Redeem
/// @notice Returns the maximum amount of shares available to redeem
#define macro MAX_REDEEM() = takes (0) returns (0) {
    0x04 calldataload               // [owner]
    [BALANCE_OF_SLOT] sload         // [balanceOf[owner]]
    0x00 mstore                     // []
    0x20 0x00 return                // []
}

// ------------------------------------------------------
// INTERNAL HOOKS LOGIC
// ------------------------------------------------------

#define macro BEFORE_WITHDRAW() = takes (2) returns (0) {
    // Input Stack: [assets, shares]
    // Output Stack: []
    // TODO: OVERRIDE
}

#define macro AFTER_DEPOSIT() = takes (2) returns (0) {
    // TODO:
}

// ------------------------------------------------------
// DISPATCH LOGIC
// ------------------------------------------------------

/// @notice An internal function dispatcher
#define macro INNER_4626_MAIN() = takes (1) returns (1) {
    // Input stack: [func_selector]
    // Output stack: [func_selector]

    dup1 __FUNC_SIG(decimals) eq decimals_jump jumpi    // [func_selector]
    dup1 __FUNC_SIG(asset) eq asset_jump jumpi          // [func_selector]

    MAIN_ERC20()                                        // [func_selector]

    cont jump

    decimals_jump:
        ERC4626_DECIMALS()
    asset_jump:
        ERC4626_ASSET()

    // Resume parent dispatching
    cont:
}