#define error ErrorCreatingProxy()
#define error ErrorCreatingContract()
#define error TargetAlreadyExists()

#define function deploy(bytes32,bytes,uint256) payable returns (address)

/*
    push8 0x67363d37363d34f0
    returndatasize
    mstore
    push1 0x08
    push1 0x18
    return    
*/
#define constant PROXY_BYTECODE = 0x67363d3d37363d34f03d5260086018f3 
#define constant PROXY_BYTECODE_HASH = 0x21c35dbe1b344a2488cf3321d6ce542f8e9f305544ff09e4993a62319a497c1f


// TODO: replace this with the keccak of the bytecode
// #define constant PROXY_BYTECODE_HASH = TOOD: keccak the proxy bytecode


#define macro DEPLOY() = takes(0) returns(0) {

    // TODO: Do we need to return the mem pointer in LOAD_ARRAY_INTO_MEM it kinna fucks stuff up
    // Load the creation code into memory
    0x04 calldataload               // [salt]
    0x00                            // [0x00, salt]
    dup1                            // [&offset, &mem, salt] - location to store memory at
    __LOAD_ARRAY_INTO_MEM(0x24)     // [&offset, len(arr), &mem, salt] - new clean memory pointer
    
    0x00                            // [0x00, &offset, len(arr), &mem, salt]                   

    // Deploy the proxy 
    create2                         // [proxy, &mem, salt]


    // Check the address of of the proxy is not null
    dup1 eq                         // [proxy, proxy, salt]
    iszero eq fail jumpi            // [proxy, salt]


    // this overwrites memory, pass memory pointer
    swap2             // [salt, proxy]
    GET_DEPLOYED()    // [deployed, proxy]
    dup1 extcodesize  // [deployed_size, deployed, proxy]
    
    // revert if failed to create proxy
    iszero eq fail jumpi   // [deployed, address]


    0x00                            // [0x00, deployed, proxy] 
    dup1                            // [0x00, 0x00, deployed, proxy]   
    dup1                            // [0x00, 0x00, 0x00, deployed, proxy]
    __LOAD_ARRAY_INTO_MEM(0x24)     // [0x00, 0x00, len(arr), &mem, deployed, proxy]
    0x44 calldataload               // [value, 0x00, 0x00, len(arr), &mem, deployed, proxy]
    dup7                            // [proxy, value, 0x00, 0x00, len(arr), &mem, deployed, proxy]
    gas                             // [gas, proxy, value, 0x00, 0x00, len(arr), &mem, deployed, proxy]
    call                            // [success, deployed, proxy]

    iszero eq fail jumpi            // [deployed, proxy]

    0x00 mstore
    0x20 0x00 return 

    fail:
        0x00 dup1 revert
}

#define macro __GET_DEPLOYED() = takes(2) returns(1) {
    // init stack : [salt, &mem]
    // Returns: [deployed_address]
    __RIGHTPAD(0xff)        // [rightpad(0xff)]
    address 0x58 shl        // [rightpad(address), rightpad(0xff)]
    or                      // [ [0xff][address]]
    0x00 mstore
                            // []               // load salt into memory
    [PROXY_BYTECODE_HASH]   // [hash]           // load hash into memory
    0x15 mstore             // []               // load proxy bytecode hash into memory

    0x35 0x00 sha3          // [keccak]

    // Shift right by 2 bytes
    0x10 shr                // [proxy_address]

    // return rpl encoded
    __RIGHTPAD(0xd69a)     // [0xd69a, proxy_address] 
    or                     // [ [0xd69a][proxy_address] ]
    

    0x01 0x50 shr
    or 
    0x00 mstore
    0x23 0x00 sha3

    0x60 shr 
}


/** Util to calldata into memory
    returns the current free memory from the stack
*/
#define macro __LOAD_ARRAY_INTO_MEM(calldata_offset) = takes(1) returns(2) {
    // Initial stack [&mem] - memory offset  
    0x20                            // [0x20, &mem]
    <calldata_offset> calldataload  // [&arr, 0x20, &mem] 
    dup1                            // [&arr, &arr, 0x20, &mem]

    // loop over the creation code to store it into mem
    calldataload                    // [len(arr), &arr, 0x20, &mem]
    0x00                            // [i, len(arr), 0x20, &mem]

    startMemoryLoad:
    dup2 dup2 eq                    // [if (i == len(arr), i, len(arr), &cc, 0x20, &mem)   
    endMemoryLoad jumpi             // [jump to end]
        // Loop initial stack [i, len(arr), &arr, 0x20, &mem]
        swap2                       // [&arr, len(arr), i, 0x20, &mem]
        dup4                        // [0x20, &arr, len(arr), i, 0x20, &mem]
        add                         // [&arr++, i, len(arr), 0x20, &mem]
        dup1                        // [&arr++, &arr++, i, len(arr), 0x20, &mem]
        calldataload                // [arr[i], &arr++, i, len(arr), 0x20, &mem]

        // Store the value into memory in slot mem_offset + (i * 0x20)
        swap5                       // [&mem, &arr++, i, len(arr), 0x20, arr[i]]
        dup5                        // [0x20, &mem, &arr++, i, len(arr), 0x20, arr[i]]
        add                         // [&mem++, &arr++, i, len(arr), 0x20, arr[i]]
        dup1                        // [&mem++, &mem++, &arr++, i, len(arr), 0x20, arr[i]] 
        swap6                       // [arr[i], &mem++, &mem++, &arr++, i, len(arr), 0x20]
        swap1 mstore                // [&mem++, &arr++, i, len(arr), 0x20]

        // jump back to start memory load for each memory item
        startMemoryLoad jump
    endMemoryLoad:

    // Stack after loop
    // [&mem++, &arr++, i, len(arr), 0x20]

    swap4                           // [0x20, &arr++, i, len(arr), &mem++,]      
    pop pop pop                     // [len(arr), &mem++]

    // Returns:
    // [len(arr), &mem]
}



#define macro MAIN() = {

    pc calldataload 0xe0 shr
    dup1 __FUNC_SIG(deploy) eq jumpi

    // Exit if selector does not match
    returndatasize dup1 revert

    deploy:
        DEPLOY()
           
}