// TODO: Add function wrappers for macros once #164 is merged in huff-rs

#define constant WAD = 0x0de0b6b3a7640000

// https://github.com/Rari-Capital/solmate/blob/v7/src/utils/FixedPointMathLib.sol#L13
#define macro MUL_WAD_DOWN() = takes (2) returns (1) {
    // Input stack:            [x, y]
    [WAD]                   // [WAD, x, y]
    ARRANGE_STACK_MULWAD()  // [x, y, WAD]
    MUL_DIV_DOWN()          // [result]
}

// https://github.com/Rari-Capital/solmate/blob/v7/src/utils/FixedPointMathLib.sol#L17
#define macro MUL_WAD_UP() = takes (2) returns (1) {
    // Input stack:            [x, y]
    [WAD]                   // [WAD, x, y]
    ARRANGE_STACK_MULWAD()  // [x, y, WAD]
    MUL_DIV_UP()            // [result]
}

// https://github.com/Rari-Capital/solmate/blob/v7/src/utils/FixedPointMathLib.sol#L21
#define macro DIV_WAD_DOWN() = takes (2) returns (1) {
    // Input stack:            [x, y]
    [WAD]                   // [WAD, x, y]
    ARRANGE_STACK_DIVWAD()  // [x, WAD, y]
    MUL_DIV_DOWN()
}

// https://github.com/Rari-Capital/solmate/blob/v7/src/utils/FixedPointMathLib.sol#L25
#define macro DIV_WAD_UP() = takes (2) returns (1) {
    // Input stack:            [x, y]
    [WAD]                   // [WAD, x, y]
    ARRANGE_STACK_DIVWAD()  // [x, WAD, y]
    MUL_DIV_UP()            // [result]
}

// https://github.com/Rari-Capital/solmate/blob/v7/src/utils/FixedPointMathLib.sol#L34
#define macro EXP_WAD() = takes (1) returns (1) {
    // Input stack:            [x]

    0xfffffffffffffffffffffffffffffffffffffffffffffffdb731c958f34d94c1
    dup2                    // [x, 0xfff..., x]
    sgt iszero              // [x <= 0xfff..., x]
    ret_zero jumpi          // [x]

    0x0755bf798b4a1bf1e5    // [0x755bf798b4a1bf1e5, x]
    dup2                    // [x, 0x755bf798b4a1bf1e5, x]
    slt iszero              // [x >= 0x755bf798b4a1bf1e5, x]
    fail jumpi              // [x]

    0x12 0x05 exp           // [0x05 ** 0x12, x]
    swap1                   // [x, 0x05 ** 0x12]
    0x4e shl                // [x << 0x4e, 0x05 ** 0x12]
    sdiv                    // [x << 0x4e / 0x05 ** 0x12]

    0xb17217f7d1cf79abc9e3b398
    dup2                    // [x, 0xb17217f7d1cf79abc9e3b398, x]
    0x60 shl                // [x << 96, 0xb17217f7d1cf79abc9e3b398, x]
    sdiv                     // [x << 96 / 0xb17217f7d1cf79abc9e3b398, x]
    0x5f 0x02 exp           // [2**95, x << 96 / 0xb17217f7d1cf79abc9e3b398, x]
    add                     // [2**95 + x << 96 / 0xb17217f7d1cf79abc9e3b398, x]
    0x60 sar                // [(2**95 + x << 96 / 0xb17217f7d1cf79abc9e3b398) >> 96, x]

    dup1                    // [(2**95 + x << 96 / 0xb17217f7d1cf79abc9e3b398) >> 96, (2**95 + x << 96 / 0xb17217f7d1cf79abc9e3b398) >> 96, x]
    0xb17217f7d1cf79abc9e3b398
    mul                     // [((2**95 + x << 96 / 0xb17217f7d1cf79abc9e3b398) >> 96) * 0xb17217f7d1cf79abc9e3b398, (2**95 + x << 96 / 0xb17217f7d1cf79abc9e3b398) >> 96, x]
    dup3                    // [x, ((2**95 + x << 96 / 0xb17217f7d1cf79abc9e3b398) >> 96) * 0xb17217f7d1cf79abc9e3b398, (2**95 + x << 96 / 0xb17217f7d1cf79abc9e3b398) >> 96, x]
    sub                     // [x (new), (2**95 + x << 96 / 0xb17217f7d1cf79abc9e3b398) >> 96, x]
    swap2 pop               // [k, x]

    0x10fe68e7fd37d0007b713f7650
    dup3                    // [x, 0x10fe68e7fd37d0007b713f7650, k, x]
    add                     // [y, k, x]

    0x02d16720577bd19bf614176fe9ea
    dup2 dup5 mul           // [x * y, 0x02d16720577bd19bf614176fe9ea, y, k, x]
    0x60 sar                // [(x * y) >> 0x60, 0x02d16720577bd19bf614176fe9ea, y, k, x]
    add                     // [((x * y) >> 0x60) + 0x02d16720577bd19bf614176fe9ea, y, k, x]
    swap1 pop               // [y, k, x]

    0x04a4fd9f2a8b96949216d2255a6c
    dup4 dup3 add           // [x + y, 0x04a4fd9f2a8b96949216d2255a6c, y, k, x]
    sub                     // [x + y - 0x04a4fd9f2a8b96949216d2255a6c, y, k, x]
    
    dup2                    // [y, x + y - 0x04a4fd9f2a8b96949216d2255a6c, y, k, x]
    mul                     // [y * (x + y - 0x04a4fd9f2a8b96949216d2255a6c), y, k, x]
    0x60 sar                // [(y * (x + y - 0x04a4fd9f2a8b96949216d2255a6c)) >> 0x60, y, k, x]
    0x0587f503bb6ea29d25fcb740196450
    add                     // [p, y, k, x]

    dup4                    // [x, p, y, k, x]
    mul                     // [x * p, y, k, x]
    0xd835ebba824c98fb31b83b2ca45c
    0x60 shl                // [0xd835ebba824c98fb31b83b2ca45c << 0x60, x * p, y, k, x]
    add                     // [p, y, k, x]

    0x240c330e9fb2d9cbaf0fd5aafc
    dup5 sub                // [q, p, y, k, x]

    dup5 mul                // [x * q, p, y, k, x]
    0x60 sar                // [(x * q) >> 0x60, p, y, k, x]
    0x0277594991cfc85f6e2461837cd9
    add                     // [q, p, y, k, x]

    dup5 mul                // [x * q, p, y, k, x]
    0x60 sar                // [(x * q) >> 0x60, p, y, k, x]
    0x1a521255e34f6a5061b25ef1c9c4 swap1
    sub                     // [q, p, y, k, x]

    dup5 mul                // [x * q, p, y, k, x]
    0x60 sar                // [(x * q) >> 0x60, p, y, k, x]
    0xb1bbb201f443cf962f1a1d3db4a5
    add                     // [q, p, y, k, x]

    dup5 mul                // [x * q, p, y, k, x]
    0x60 sar                // [(x * q) >> 0x60, p, y, k, x]
    0x02c72388d9f74f51a9331fed693f15 swap1
    sub                     // [q, p, y, k, x]

    dup5 mul                // [x * q, p, y, k, x]
    0x60 sar                // [(x * q) >> 0x60, p, y, k, x]
    0x05180bb14799ab47a8a8cb2a527d57
    add                     // [q, p, y, k, x]

    swap1 sdiv              // [p / q (r), y, k, x]
    
    0x029d9dc38563c32e5c2f6dc192ee70ef65f9978af3
    mul                     // [0x29d9... * r, y, k, x]
    dup3                    // [k, 0x29d9... * r, y, k, x]
    0xc3 sub                // [0xc3 - k, 0x29d9... * r, y, k, x]
    shr                     // [(0x29d9... * r) >> 0xc3 - k, y, k, x]

    finish jump

    fail:
        0x00 0x00 revert
    ret_zero:
        0x00 0x00 mstore
        0x20 0x00 return
    finish:
        // ...
}

// https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol#L34
#define macro MUL_DIV_DOWN() = takes (3) returns (1) {
    // Input stack:      [x, y, denominator]
    dup3              // [denominator, x, y, denominator]
    dup3              // [y, denominator, x, y, denominator]
    dup3              // [x, y, denominator, x, y, denominator]

    mul               // [x * y, denominator, x, y, denominator]
    0x00 mstore       // [denominator, x, y, denominator]

    iszero iszero     // [denominator != 0, x, y, denominator]

    swap1             // [x, denominator != 0, y, denominator]
    dup1              // [x, x, denominator != 0, y, denominator]
    iszero            // [x == 0, x, denominator != 0, y, denominator]

    swap1             // [x, x == 0, denominator != 0, y, denominator]
    0x00 mload        // [x * y, x, x == 0, denominator != 0, y, denominator]
    div               // [(x * y) / x, x == 0, denominator != 0, y, denominator]

    dup4              // [y, (x * y) / x, x == 0, denominator != 0, y, denominator]
    eq                // [y == (x * y) / x, x == 0, denominator != 0, y, denominator]
    or                // [y == (x * y) / x | x == 0, denominator != 0, y, denominator]
    and               // [(y == (x * y) / x | x == 0) & denominator != 0, y, denominator]

    iszero fail jumpi // Revert if (y == (x * y) / x | x == 0) & denominator != 0 is not satisfied

    pop               // [denominator]
    0x00 mload        // [x * y, denominator]
    div               // [(x * y) / denominator]

    finish jump

    fail:
        0x00 0x00 revert
    finish:
    // Return stack:     [(x * y) / denominator]
}

// https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol#L53
#define macro MUL_DIV_UP() = takes (3) returns (1) {
    // Input stack:      [x, y, denominator]
    dup3              // [denominator, x, y, denominator]
    dup3              // [y, denominator, x, y, denominator]
    dup3              // [x, y, denominator, x, y, denominator]

    mul               // [x * y, denominator, x, y, denominator]
    0x00 mstore       // [denominator, x, y, denominator]

    iszero iszero     // [denominator != 0, x, y, denominator]

    dup2              // [x, denominator != 0, x, y, denominator]
    iszero            // [x == 0, denominator != 0, x, y, denominator]

    dup3              // [x, x == 0, denominator != 0, x, y, denominator]
    0x00 mload        // [x * y, x, x == 0, denominator != 0, x, y, denominator]
    div               // [(x * y) / x, x == 0, denominator != 0, x, y, denominator]

    dup5              // [y, (x * y) / x, x == 0, denominator != 0, x, y, denominator]
    eq                // [y == (x * y) / x, x == 0, denominator != 0, x, y, denominator]
    or                // [y == (x * y) / x | x == 0, denominator != 0, x, y, denominator]
    and               // [y == (x * y) / x | x == 0 & denominator != 0, x, y, denominator]

    iszero fail jumpi // Revert if (y == (x * y) / x | x == 0) & denominator != 0 is not satisfied

    0x00 mload        // [x * y, x, y, denominator]
    iszero iszero     // [x * y != 0, x, y, denominator]

    dup4              // [denominator, x * y != 0, x, y, denominator]
    0x01              // [1, denominator, x * y != 0, x, y, denominator]
    0x00 mload        // [x * y, 1, denominator, x * y != 0, x, y, denominator]
    sub               // [x * y - 1, denominator, x * y != 0, x, y, denominator]
    div               // [x * y - 1 / denominator, x * y != 0, x, y, denominator]
    0x01              // [1, x * y - 1 / denominator, x * y != 0, x, y, denominator]
    add               // [(x * y - 1 / denominator) + 1, x * y != 0, x, y, denominator]

    mul               // [((x * y - 1 / denominator) + 1) * (x * y != 0), x, y, denominator]

    // Clear extra stack items before continuing
    swap3             // [denominator, x, y, ((x * y - 1 / denominator) + 1) * (x * y != 0)]
    pop pop pop       // [((x * y - 1 / denominator) + 1) * (x * y != 0)]

    finish jump

    fail:
        0x00 0x00 revert
    finish:
    // Return stack:     [((x * y - 1 / denominator) + 1) * (x * y != 0)]
}

// https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol#L74
// TODO: Optimize, works but not great
#define macro RPOW() = takes (3) returns (1) {
    // Input stack:                [x, n, scalar]
    dup1                        // [x, x, n, scalar]

    iszero zero jumpi           // Jump to "zero" if x == 0
    default jump                // Jump to "default" if x != 0

    zero:
        dup2                    // [n, x, n, scalar]

        iszero zero_inner jumpi // If n == 0 && x == 0, return the scalar (0 ** 0 = 1).
        zero_default jumpi      // If n != 0 && x == 0, return 0.

        // 0 ** 0 = 1
        zero_inner:
            swap2               // [scalar, n, x]
            0x60 mstore         // [n, x]
            finish jump         // Finish execution
        // 0 ** n = 0
        zero_default:
            // 0x60 is blank, no need to set it.
            pop                 // [n, scalar] - Others will be popped in `finish`
            finish jump         // Finish execution
    default:
        0x20 mstore             // [n, scalar]
        0x40 mstore             // [scalar]
            
        dup1                    // [scalar, scalar]
        0x01 shr                // [scalar >> 1, scalar]
        0x00 mstore             // [scalar]

        0x02                    // [2, scalar]
        0x40 mload              // [n, 2, scalar]
        mod                     // [n % 2, scalar]

        iszero even jumpi       // Set result to scalar for now if n % 2 is even
        odd jump                // Set result to x for now if n % 2 is odd

        // n % 2 is even
        even:
            dup1                // [scalar, scalar]
            0x60 mstore         // [scalar]
            loop jump           // Start loop
        // n % 2 is odd
        odd:
            0x20 mload          // [x, scalar]
            0x60 mstore         // [scalar]
            loop jump           // Start loop
        loop:
            0x40 mload          // [n, scalar]
            dup1                // [n, n, scalar]

            iszero finish jumpi // If n = 0, the loop is finished.

            // Divide n by 2
            0x01 shr            // [n >> 1, scalar]
            0x40 mstore         // [scalar]

            // Revert if x ** 2 will overflow.
            0x20 mload          // [x, scalar]
            0x80 shr            // [x >> 128, scalar]
            fail jumpi          // [scalar]

            // Square x and duplicate it on the stack for use later.
            0x20 mload          // [x, scalar]
            dup1 mul            // [x * x, scalar]
            dup1                // [x * x, x * x, scalar]

            // Add x ** 2 to scalar >> 1
            0x00 mload          // [scalar >> 1, x * x, x * x, scalar]
            add                 // [(scalar >> 1) + (x * x), x * x, scalar]

            // Revert if x ** 2 + scalar >> 1 overflowed
            swap1               // [x * x, (scalar >> 1) + (x * x), scalar]
            dup2                // [(scalar >> 1) + (x * x), x * x, (scalar >> 1) + (x * x), scalar]
            lt fail jumpi       // [(scalar >> 1) + (x * x), scalar]

            // Set x to ((scalar >> 1) + (x * x)) / scalar
            dup2                // [scalar, (scalar >> 1) + (x * x), scalar]
            swap1               // [(scalar >> 1) + (x * x), scalar, scalar]
            div                 // [((scalar >> 1) + (x * x)) / scalar, scalar]
            0x20 mstore         // [scalar]

            0x02                // [2, scalar]
            0x40 mload          // [n, 2, scalar]
            mod                 // [n % 2, scalar]

            // If n is odd, continue logic
            odd_inner jumpi
            // If n is even, continue loop
            loop jump
        odd_inner:
            // Multiply x * result
            0x60 mload          // [result]
            0x20 mload          // [x, result]
            mul                 // [x * result]
            dup1                // [x * result, x * result]
            dup1                // [x * result, x * result, x * result]

            // Check if x * result overflowed
            0x20 mload          // [x, x * result, x * result, x * result]
            swap1               // [x * result, x, x * result, x * result]
            div                 // [x * result / x, x * result, x * result]
            0x60 mload          // [result, x * result / x, x * result, x * result]
            eq iszero           // [result != (x * result / x), x * result, x * result]
            0x20 mload          // [x, result != (x * result / x), x * result, x * result]
            iszero iszero       // [x != 0, result != (x * result / x), x * result, x * result]
            and fail jumpi      // Revert if x * result overflowed

            // Round to the nearest number
            0x00 mload          // [scalar >> 1, x * result, x * result]
            add                 // [(scalar >> 1) + (x * result), x * result]

            // Check if x ** 2 + scalar >> 1 overflowed
            swap1               // [x * result, (scalar >> 1) + (x * result)]
            dup2                // [(scalar >> 1) + (x * result), x * result, (scalar >> 1) + (x * result)]
            lt fail jumpi       // Revert if ((scalar >> 1) + (x * result)) < x * result

            // Scale rounded result
            dup2                // [scalar, ((scalar >> 1) + (x * result), scalar]
            swap1               // [((scalar >> 1) + (x * result), scalar, scalar]
            div                 // [((scalar >> 1) + (x * result)) / scalar, scalar]
            0x60 mstore         // [scalar]

            loop jump           // Continue loop
        // Revert
        fail:
            0x00 0x00 revert
        // Return result
        finish:
            pop pop             // [] - Clear stack
            0x60 mload          // [result]
}

#define macro ARRANGE_STACK_MULWAD() = takes (0) returns (0) {
    // Input stack: [WAD, x, y]
    swap2        // [y, x, WAD]
    swap1        // [x, y, WAD]
}

#define macro ARRANGE_STACK_DIVWAD() = takes (0) returns (0) {
    // Input stack: [WAD, x, y]
    swap1        // [x, WAD, y]
}