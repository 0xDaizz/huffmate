#define function multicall(bytes[] calldata) payable returns (bytes[] memory)
#define function call1() view returns (uint256)
#define function call2() view returns (uint256)
#define function call3() view returns (uint256)
#define function returnsTuple(uint256, uint256) view returns (uint256, uint256)
#define function returnsStr(string) view returns (string)
#define function returnsSender() view returns (address)
#define function pay() payable returns (uint256)
#define function paid() view returns (uint256)
#define function revertsNoMsg() view returns ()
#define function revertsMsg() view returns ()

#define constant PAID_SLOT = FREE_STORAGE_POINTER()

#define macro CALL_1() = takes (0) returns (0) {
    0x11 0x00 mstore
    0x20 0x00 return
}

#define macro CALL_2() = takes (0) returns (0) {
    0x22 0x00 mstore
    0x20 0x00 return
}

#define macro CALL_3() = takes (0) returns (0) {
    0x33 0x00 mstore
    0x20 0x00 return
}

#define macro RETURNS_TUPLE() = takes (0) returns (0) {
    0x04 calldataload // [x]
    0x00 mstore       // []
    0x24 calldataload // [y]
    0x20 mstore       // []
    0x40 0x00 return
}

#define macro RETURNS_STR() = takes (0) returns (0) {
    0x24 calldataload // [str_len]
    0x40 add          // [str_len + 0x40]
    dup1              // [str_len + 0x40, str_len + 0x40]
    0x04              // [0x04, str_len + 0x40, str_len + 0x40]
    0x00              // [0x00, 0x04, str_len + 0x40, str_len + 0x40]
    calldatacopy      // [str_len + 0x40]
    0x00 return
}

#define macro RETURNS_SENDER() = takes (0) returns (0) {
    caller            // [msg.sender]
    0x00 mstore       // []
    0x20 0x00 return
}

#define macro PAY() = takes (0) returns (0) {
    [PAID_SLOT] sload  // [paid]
    callvalue add      // [paid + callvalue]
    [PAID_SLOT] sstore // []
    0x00 dup1 return
}

#define macro PAID() = takes (0) returns (0) {
    [PAID_SLOT] sload  // [paid]
    0x00 mstore        // []
    0x20 0x00 return 
}

#define macro REVERTS_NO_MSG() = takes (0) returns (0) {
    0x00 dup1 revert
}

#define macro REVERTS_MSG() = takes (0) returns (0) {
    0x5465737420526576657274000000000000000000000000000000000000000000 
    0x00 mstore
    0x0B 0x00 revert
}

#define macro MAIN() = takes (0) returns (0) {
    pc calldataload 0xE0 shr
    dup1 __FUNC_SIG(multicall)     eq multicall      jumpi
    dup1 __FUNC_SIG(call1)         eq call_one       jumpi
    dup1 __FUNC_SIG(call2)         eq call_two       jumpi
    dup1 __FUNC_SIG(call3)         eq call_three     jumpi
    dup1 __FUNC_SIG(returnsTuple)  eq returns_tuple  jumpi
    dup1 __FUNC_SIG(returnsStr)    eq returns_str    jumpi
    dup1 __FUNC_SIG(returnsSender) eq returns_sender jumpi
    dup1 __FUNC_SIG(pay)           eq pay            jumpi
    dup1 __FUNC_SIG(paid)          eq paid           jumpi
    dup1 __FUNC_SIG(revertsNoMsg)  eq revert_no_msg  jumpi
    dup1 __FUNC_SIG(revertsMsg)    eq revert_msg     jumpi

    0x00 dup1 revert

    multicall:
        MULTICALL()
    call_one:
        CALL_1()
    call_two:
        CALL_2()
    call_three:
        CALL_3()
    returns_tuple:
        RETURNS_TUPLE()
    returns_str:
        RETURNS_STR()
    returns_sender:
        RETURNS_SENDER()
    pay:
        PAY()
    paid:
        PAID()
    revert_no_msg:
        REVERTS_NO_MSG()
    revert_msg:
        REVERTS_MSG()
}

/// @title Multicallable
/// @notice SPDX-License-Identifier: MIT
/// @author clabby <https://github.com/clabby>
/// @notice Enables a single call to call multiple methods within a contract.
/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/Multicallable.sol)
/// @author Adapted from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/Multicallable.sol)

// Calldata
#define constant DATA_LEN = 0x24
#define constant DATA_OFFSET = 0x44
// Memory
#define constant RES = 0x20
#define constant RES_OFF = 0x40

/// @notice Multicall function entry point.
/// @dev This macro should be placed alone under a function selector's jump label.
///
///      Expected calldata: `bytes[]` containing valid ABI-encoded function calls
///      as elements.
///
///      Note: this macro only allows for multicalling functions that are within
///      the contract it is invoked in.
#define macro MULTICALL() = takes (0) returns (0) {
    // Input stack:       []

    // Store pointer to array contents @ 0x00
    0x20 0x00 mstore   // []

    [DATA_LEN]         // [data_len_ptr]
    calldataload       // [data_len]

    // Only continue if data length is > 0
    dup1 continue jumpi

    // Return blank bytes array
    0x40 0x00 return

    continue:

    dup1               // [data_len, data_len]
    [RES]              // [res_ptr, data_len, data_len]
    mstore             // [data_len]

    [RES_OFF]          // [results_offset, data_len]

    // Copy the offsets from calldata into memory.
    swap1              // [data_len, results_offset]
    0x05 shl           // [data_len * 0x20, results_offset]
    dup1               // [data_len * 0x20, data_len * 0x20, results_offset]
    [DATA_OFFSET]      // [data_offset, data_len * 0x20, data_len * 0x20, results_offset]
    dup4               // [results_offset, data_offset, data_len * 0x20, data_len * 0x20, results_offset]
    calldatacopy       // [data_len * 0x20, results_offset]

    dup2 add           // [mem_ptr, results_offset]
    dup1               // [data_end, mem_ptr, results_offset]
    loop:
        // The offset of the current bytes in the calldata.
        dup3           // [results_offset, data_end, mem_ptr, results_offset]
        mload          // [result, data_end, mem_ptr, results_offset]
        [DATA_OFFSET]  // [0x44, result, data_end, mem_ptr, results_offset]
        add            // [o, data_end, mem_ptr, results_offset]

        // Copy the current bytes from calldata to the memory.
        dup1           // [o, o, data_end, mem_ptr, results_offset]
        calldataload   // [cur_bytes_len, o, data_end, mem_ptr, results_offset]
        dup2 0x20 add  // [o + 0x20, cur_bytes_len, o, data_end, mem_ptr, results_offset]
        dup5           // [mem_ptr, o + 0x20, cur_bytes_len, o, data_end, mem_ptr, results_offset]
        calldatacopy   // [o, data_end, mem_ptr, results_offset]

        calldataload   // [cur_bytes_len, data_end, mem_ptr, results_offset]
        0x00 dup1      // [0x00, 0x00, cur_bytes_len, data_end, mem_ptr, results_offset]
        swap2          // [cur_bytes_len, 0x00, 0x00, data_end, mem_ptr, results_offset]
        dup5           // [mem_ptr, cur_bytes_len, 0x00, 0x00, data_end, mem_ptr, results_offset]
        address        // [self_addr, mem_ptr, cur_bytes_len, 0x00, 0x00, data_end, mem_ptr, results_offset]
        gas            // [gas, self_addr, mem_ptr, cur_bytes_len, 0x00, 0x00, data_end, mem_ptr, results_offset]
        delegatecall   // [call_result, data_end, mem_ptr, results_offset]

        // Bubble up the revert if the delegatecall reverts
        iszero fail jumpi // [data_end, mem_ptr, results_offset]

        // Increment `results_offset` by 0x20
        0x40 dup3 sub  // [mem_ptr - 0x40, data_end, mem_ptr, results_offset]
        dup4 mstore    // [data_end, mem_ptr, results_offset]
        dup3 0x20 add  // [results_offset + 0x20, data_end, mem_ptr, results_offset]
        swap3 pop      // [data_end, mem_ptr, results_offset]

        // Append the `returndatasize()`, and the return data.
        returndatasize // [ret_data_size, data_end, mem_ptr, results_offset]
        dup3           // [mem_ptr, ret_data_size, data_end, mem_ptr, results_offset]
        mstore         // [data_end, mem_ptr, results_offset]
        returndatasize // [ret_data_size, data_end, mem_ptr, results_offset]
        0x00           // [0x00, ret_data_size, data_end, mem_ptr, results_offset]
        dup4 0x20 add  // [mem_ptr + 0x20, 0x00, ret_data_size, data_end, mem_ptr, results_offset]
        returndatacopy // [data_end, mem_ptr, results_offset]

        // Advance the `memPtr` by `returndatasize() + 0x20`,
        // rounded up to the next multiple of 32.
        0xffffffffffffffe0
        0x3f           // [0x3f, 0xf..e0, data_end, mem_ptr, results_offset]
        returndatasize // [ret_data_size, 0x3f, 0xf..e0, data_end, mem_ptr, results_offset]
        dup5 add       // [mem_ptr + ret_data_size, 0x3f, 0xf..e0, data_end, mem_ptr, results_offset]
        add and        // [(mem_ptr + ret_data_size + 0x3f) & 0xf..e0, data_end, mem_ptr, results_offset]
        swap2 pop      // [data_end, mem_ptr, results_offset]

        // Continue loop if results_offset < data_end
        dup1 dup4 lt   // [results_offset < data_end, data_end, mem_ptr, results_offset]
        loop jumpi     // [data_end, mem_ptr, results_offset]

        swap1          // [mem_ptr, data_end, results_offset]
        0x00           // [ret_mem_ptr, mem_ptr, data_end, results_offset]
        return
    fail:
        returndatasize // [ret_data_size, data_end, mem_ptr, results_offset]
        0x00 dup1      // [0x00, 0x00, ret_data_size, data_end, mem_ptr, results_offset]
        returndatacopy // [ret_data_size, data_end, mem_ptr, results_offset]
        returndatasize 0x00 revert
}