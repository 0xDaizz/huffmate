// https://github.com/Rari-Capital/solmate/blob/v7/src/utils/MerkleProofLib.sol
#define macro VERIFY_PROOF() = takes (3) returns (1) {
    // Input Stack:        [proof_cd_ptr, leaf, root]

    // Store end of input arr offset in memory @ 0x40
    dup1 calldataload   // [proof_arr_len, proof_cd_ptr, leaf, root]
    0x05 shl            // [proof_arr_len << 5, proof_cd_ptr, leaf, root]
    swap1 0x20 add      // [proof_cd_ptr + 0x20, proof_arr_len << 5, leaf, root]
    dup1 swap2          // [proof_cd_ptr + 0x20, proof_arr_len << 5, proof_cd_ptr + 0x20, leaf, root]
    add                 // [proof_cd_ptr + 0x20 + proof_arr_len << 5, proof_cd_ptr + 0x20, leaf, root]
    0x40 mstore         // [proof_cd_ptr + 0x20, leaf, root]

    // Store loop index in memory @ 0x60
    0x60 mstore         // [leaf, root]

    loop:
        0x40 mload      // [proof_arr_end, leaf, root]
        0x60 mload      // [loop_idx, proof_arr_end, leaf, root]
        lt              // [loop_idx < proof_arr_end, leaf, root]
        // If loop index is >= the proof arr end offset, finish the loop
        iszero finish jumpi

        // Load data at proof_arr[loop_idx]
        0x60 mload      // [loop_idx, leaf, root]
        calldataload    // [proof_arr[loop_idx], leaf, root]

        dup1            // [proof_arr[loop_idx], proof_arr[loop_idx], leaf, root]
        dup3            // [leaf, proof_arr[loop_idx], proof_arr[loop_idx], leaf, root]
        gt              // [leaf > proof_arr[loop_idx], proof_arr[loop_idx], leaf, root]
        0x05 shl        // [leaf > proof_arr[loop_idx] << 5, proof_arr[loop_idx], leaf, root]

        dup3            // [leaf, leaf > proof_arr[loop_idx] << 5, proof_arr[loop_idx], leaf, root]
        dup2            // [leaf > proof_arr[loop_idx] << 5, leaf, leaf > proof_arr[loop_idx] << 5, proof_arr[loop_idx], leaf, root]
        mstore          // [leaf > proof_arr[loop_idx] << 5, proof_arr[loop_idx], leaf, root]

        0x20 xor        // [(leaf > proof_arr[loop_idx] << 5) ^ 0x20, proof_arr[loop_idx], leaf, root]
        mstore          // [leaf, root]

        pop             // [root]
        0x40 0x00 sha3  // [leaf, root]

        // Add 32 to ptr
        0x60 mload      // [loop_idx, leaf, root]
        0x20 add        // [loop_idx + 0x20, leaf, root]
        0x60 mstore     // [leaf, root]

        loop jump
    finish:
        eq              // [root == leaf]
}