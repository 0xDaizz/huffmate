/// @title Pausable
/// @notice SPDX-License-Identifier: MIT
/// @author zarf.eth <https://github.com/zarfsec>
/// @notice A Pausable implementation

#include "../auth/NonPayable.huff"


// Interface

/// @notice returns whether the contract is paused
#define function isPaused() view returns (bool)

/// @notice Pauses the contract 
/// @dev Only callable when the contract is unpaused.
#define function pause() nonpayable returns ()

/// @notice Unpauses the contract 
/// @dev Only callable when the contract is paused.
#define function unpause() nonpayable returns ()

/// @notice Emitted when contract is paused.
#define event Paused(address)

/// @notice Emitted when contract is unpaused.
#define event Unpaused(address)



// Storage

/// @notice Paused Storage Slot
#define constant PAUSED_SLOT = FREE_STORAGE_POINTER()

/// @notice Unpaused representation
#define constant _UNPAUSED = 0x01

/// @notice Paused representation
#define constant _PAUSED = 0x02

/// @notice cast keccak "Paused(address)"
#define constant EVENT_PAUSED = 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258

/// @notice cast keccak "Unpaused(address)"
#define constant EVENT_UNPAUSED = 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa


/// @notice Pausable constructor
#define macro PAUSABLE_CONSTRUCTOR() = takes (0) returns (0) {
    [_UNPAUSED] [PAUSED_SLOT] sstore       // []
}

/// @notice whenNotPaused modifier
#define macro WHEN_NOT_PAUSED_MODIFIER() = takes (0) returns (0) {
    [PAUSED_SLOT] sload                    // [isPaused]
    [_UNPAUSED] eq when_not_paused jumpi   // []
    0x00 dup1 revert                       // []
    when_not_paused:                       // []
}

/// @notice whenPaused modifier
#define macro WHEN_PAUSED_MODIFIER() = takes (0) returns (0) {
    [PAUSED_SLOT] sload                    // [isPaused]
    [_PAUSED] eq when_paused jumpi         // []
    0x00 dup1 revert                       // []
    when_paused:                           // []
}

/// @notice return whether contract is paused
#define macro PAUSABLE_IS_PAUSED() = takes (0) returns (0) {
    0x01                              // [1]
    [PAUSED_SLOT] sload               // [isPaused, 1]
    sub                               // [bool]
    0x00 mstore                       // []
    0x20 0x00 return                  // []
}


/// @notice Pause the contract
#define macro PAUSABLE_PAUSE() = takes (0) returns (0) {
    NON_PAYABLE()                           // []
    WHEN_NOT_PAUSED_MODIFIER()              // []

    //emit Paused(address)
    caller [EVENT_PAUSED] 0x00 dup1         // [0, 0, EVENT_PAUSED, msg.sender]
    log2                                    // []

    [_PAUSED] [PAUSED_SLOT] sstore          // []
    stop
}

/// @notice Unpause the contract
#define macro PAUSABLE_UNPAUSE() = takes (0) returns (0) {
    NON_PAYABLE()                           // []
    WHEN_PAUSED_MODIFIER()                  // []

    //emit Unpaused(address)
    caller [EVENT_UNPAUSED] 0x00 dup1       // [0, 0, EVENT_UNPAUSED, msg.sender]
    log2                                    // []

    [_UNPAUSED] [PAUSED_SLOT] sstore        // []
    stop
}


// Function Dispatching
#define macro PAUSABLE_MAIN() = takes (1) returns (1) {
    // Input stack: [sig]
    // Output stack: [sig]

    dup1 __FUNC_SIG(pause)      eq pause jumpi
    dup1 __FUNC_SIG(unpause)    eq unpause jumpi
    dup1 __FUNC_SIG(isPaused)   eq is_paused jumpi

    // Bubble up to the parent macro
    no_match jump

    pause:
        PAUSABLE_PAUSE()
    unpause:
        PAUSABLE_UNPAUSE()
    is_paused:
        PAUSABLE_IS_PAUSED()

    no_match:
}