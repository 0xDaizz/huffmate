/// @title Pausable
/// @notice SPDX-License-Identifier: MIT
/// @author zarf.eth <https://github.com/zarfsec>
/// @notice A Pausable implementation

#include "../auth/NonPayable.huff"


// Interface

/// @notice returns whether the contract is paused
#define function isPaused() view returns (bool)

/// @notice Pauses the contract 
/// @dev Only callable when the contract is unpaused.
#define function pause() nonpayable returns ()

/// @notice Unpauses the contract 
/// @dev Only callable when the contract is paused.
#define function unpause() nonpayable returns ()

/// @notice Emitted when contract is paused.
#define event Paused(address)

/// @notice Emitted when contract is unpaused.
#define event Unpaused(address)


// Storage

/// @notice Paused Storage Slot
#define constant PAUSED_SLOT = FREE_STORAGE_POINTER()


/// @notice Pausable constructor
#define macro PAUSABLE_CONSTRUCTOR() = takes (0) returns (0) {
    0x00 [PAUSED_SLOT] sstore              // []
}

/// @notice whenNotPaused modifier
#define macro WHEN_NOT_PAUSED_MODIFIER() = takes (0) returns (0) {
    [PAUSED_SLOT] sload                    // [isPaused]
    0x00 eq when_not_paused jumpi          // []
    0x00 0x00 revert                       // []
    when_not_paused:                       // []
}

/// @notice whenPaused modifier
#define macro WHEN_PAUSED_MODIFIER() = takes (0) returns (0) {
    [PAUSED_SLOT] sload                    // [isPaused]
    0x01 eq when_paused jumpi              // []
    0x00 0x00 revert                       // []
    when_paused:                           // []
}

/// @notice return whether contract is paused
#define macro PAUSABLE_IS_PAUSED() = takes (0) returns (0) {
    [PAUSED_SLOT] sload               // [isPaused]
    0x00 mstore                       // []
    0x20 0x00 return                  // []
}


/// @notice Pause the contract
#define macro PAUSABLE_PAUSE() = takes (0) returns (0) {
    NON_PAYABLE()                           // []
    WHEN_NOT_PAUSED_MODIFIER()              // []

    0x01 [PAUSED_SLOT] sstore               // []
    stop
}

/// @notice Unpause the contract
#define macro PAUSABLE_UNPAUSE() = takes (0) returns (0) {
    NON_PAYABLE()                           // []
    WHEN_PAUSED_MODIFIER()                  // []

    0x00 [PAUSED_SLOT] sstore               // []
    stop
}


// Function Dispatching
#define macro PAUSABLE_MAIN() = takes (1) returns (1) {
    // Input stack: [sig]
    // Output stack: [sig]

    dup1 __FUNC_SIG(pause)      eq pause jumpi
    dup1 __FUNC_SIG(unpause)    eq unpause jumpi
    dup1 __FUNC_SIG(isPaused)   eq is_paused jumpi

    // Bubble up to the parent macro
    no_match jump

    pause:
        PAUSABLE_PAUSE()
    unpause:
        PAUSABLE_UNPAUSE()
    is_paused:
        PAUSABLE_IS_PAUSED()

    no_match:
}