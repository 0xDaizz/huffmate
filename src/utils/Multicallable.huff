// Calldata
#define constant DATA_LEN = 0x24
#define constant DATA_OFFSET = 0x44
// Memory
#define constant RES = 0x20
#define constant RES_OFF = 0x40

/// @notice Contract that enables a single call to call multiple methods on itself.
/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/Multicallable.sol)
/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/Multicallable.sol)
/// @author clabby <https://github.com/clabby>
#define macro MULTICALL() = takes (0) returns (0) {
    // Input stack:       []
    
    // Store beginning offset
    0x20 0x00 mstore   // []

    [DATA_LEN]         // [data_len_ptr]
    calldataload       // [data_len]
    
    dup1               // [data_len, data_len]
    [RES]              // [res_ptr, data_len, data_len]
    mstore             // [data_len]

    [RES_OFF]          // [results_offset, data_len]

    // Copy the offsets from calldata into memory.
    dup2               // [data_len, results_offset, data_len]
    0x05 shl           // [data_len * 0x20, results_offset, data_len]
    dup1               // [data_len * 0x20, data_len * 0x20, results_offset, data_len]]
    [DATA_OFFSET]      // [data_offset, data_len * 0x20, data_len * 0x20, results_offset, data_len]
    dup4               // [results_offset, data_offset, data_len * 0x20, data_len * 0x20, results_offset, data_len]
    calldatacopy       // [data_len * 0x20, results_offset, data_len]

    dup2 add           // [mem_ptr, results_offset, data_len]
    dup1               // [data_end, mem_ptr, results_offset, data_len]
    loop:
        // The offset of the current bytes in the calldata.
        dup3           // [results_offset, data_end, mem_ptr, results_offset, data_len]
        mload          // [result, data_end, mem_ptr, results_offset, data_len]
        [DATA_OFFSET]  // [0x44, result, data_end, mem_ptr, results_offset, data_len]
        add            // [o, data_end, mem_ptr, results_offset, data_len]

        // Copy the current bytes from calldata to the memory.
        dup1           // [o, o, data_end, mem_ptr, results_offset, data_len]
        calldataload   // [cur_bytes_len, o, data_end, mem_ptr, results_offset, data_len]
        dup2 0x20 add  // [o + 0x20, cur_bytes_len, o, data_end, mem_ptr, results_offset, data_len]
        dup5           // [mem_ptr, o + 0x20, cur_bytes_len, o, data_end, mem_ptr, results_offset, data_len]
        calldatacopy   // [o, data_end, mem_ptr, results_offset, data_len]

        calldataload   // [cur_bytes_len, data_end, mem_ptr, results_offset, data_len]
        0x00 dup1      // [0x00, 0x00, cur_bytes_len, data_end, mem_ptr, results_offset, data_len]
        swap2          // [cur_bytes_len, 0x00, 0x00, data_end, mem_ptr, results_offset, data_len]
        dup5           // [mem_ptr, cur_bytes_len, 0x00, 0x00, data_end, mem_ptr, results_offset, data_len]
        address        // [self_addr, mem_ptr, cur_bytes_len, 0x00, 0x00, data_end, mem_ptr, results_offset, data_len]
        gas            // [gas, self_addr, mem_ptr, cur_bytes_len, 0x00, 0x00, data_end, mem_ptr, results_offset, data_len]
        delegatecall   // [call_result, data_end, mem_ptr, results_offset, data_len]

        // Bubble up the revert if the delegatecall reverts
        iszero fail jumpi // [data_end, mem_ptr, results_offset, data_len]

        // Append the current `results_offset` at `results_offset`.
        dup2 dup3      // [results_offset, mem_ptr, data_end, mem_ptr, results_offset, data_len]
        mstore         // [data_end, mem_ptr, results_offset, data_len]
        dup3 0x20 add  // [results_offset + 0x20, data_end, mem_ptr, results_offset, data_len]
        swap3 pop      // [data_end, mem_ptr, results_offset, data_len]
        
        // Append the `returndatasize()`, and the return data.
        returndatasize // [ret_data_size, data_end, mem_ptr, results_offset, data_len]
        dup3           // [mem_ptr, ret_data_size, data_end, mem_ptr, results_offset, data_len]
        mstore         // [data_end, mem_ptr, results_offset, data_len]
        returndatasize // [ret_data_size, data_end, mem_ptr, results_offset, data_len]
        0x00           // [0x00, ret_data_size, data_end, mem_ptr, results_offset, data_len]
        dup4 0x20 add  // [mem_ptr + 0x20, 0x00, ret_data_size, data_end, mem_ptr, results_offset, data_len]
        returndatacopy // [data_end, mem_ptr, results_offset, data_len]

        // Advance the `memPtr` by `returndatasize() + 0x20`,
        // rounded up to the next multiple of 32.
        0xffffffffffffffe0
        0x3f           // [0x3f, 0xf..e0, data_end, mem_ptr, results_offset, data_len]
        returndatasize // [ret_data_size, 0x3f, 0xf..e0, data_end, mem_ptr, results_offset, data_len]
        dup5 add       // [mem_ptr + ret_data_size, 0x3f, 0xf..e0, data_end, mem_ptr, results_offset, data_len]
        add and        // [(mem_ptr + ret_data_size + 0x3f) & 0xf..e0, data_end, mem_ptr, results_offset, data_len]
        swap2 pop      // [data_end, mem_ptr, results_offset, data_len]

        // Continue loop if results_offset < data_end
        dup1 dup4 lt   // [results_offset < data_end, data_end, mem_ptr, results_offset, data_len]
        loop jumpi     // [data_end, mem_ptr, results_offset, data_len]

        swap1
        0x00           // [ret_mem_ptr, mem_ptr, data_end, results_offset, data_len]
        return
    fail:
        returndatasize // [ret_data_size, data_end, mem_ptr, results_offset, data_len]
        dup1           // [ret_data_size, ret_data_size, data_end, mem_ptr, results_offset, data_len]
        0x00 dup1      // [0x00, 0x00, ret_data_size, ret_data_size, data_end, mem_ptr, results_offset, data_len]
        returndatacopy // [ret_data_size, data_end, mem_ptr, results_offset, data_len]
        0x00 revert
}