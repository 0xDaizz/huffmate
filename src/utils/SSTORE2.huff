/// @title SSTORE2
/// @notice SPDX-License-Identifier: MIT
/// @author asnared <https://github.com/abigger87>
/// @notice Faster & cheaper contract key-value storage for Ethereum Contracts
/// @notice Adapted from 0xsequence/sstore2 (https://github.com/0xsequence/sstore2)

#include "./Bytecode.huff"

#define constant TYPE_UINT_256_MAX = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff

#define error WriteError()

/// @notice Stores `_data` and returns `pointer` as key for later retrieval
/// @dev The pointer is a contract address with `_data` as code
/// @param {_data} [bytes memory] to be written
/// @return pointer Pointer to the written `_data`
#define macro SSTORE2_WRITE() = takes (0) returns (1) {
    // Load the data memory pointer
    0x04 calldataload                 // [&_data]

    // Load the data length
    dup1 mload                        // [&_data, _data.length]
    dup2 0x20 add                     // [_data, &_data, _data.length]

    // Loop over the data and store in memory at a new pointer
    0x00                              // [i, _data, &_data, _data.length]

    loop:
      // Store the data in memory at a 2 byte offset position
      dup2 mload                      // [_data[i], i, _data, &_data, _data.length]
      dup2                            // [i, _data[i], i, _data, &_data, _data.length]
      0x02 add                        // [i + 0x02, _data[i], &_data, i, _data.length]
      mstore                          // [i, _data, &_data, _data.length]

      // Increment our counter
      swap1 0x20 add                  // [_data + 0x20, i, &_data, _data.length]
      swap1 0x20 add                  // [i + 0x20, _data + 0x20, &_data, _data.length]

      // Only loop if i < _data.length
      dup4 dup2 lt loop jumpi         // [i, _data, &_data, _data.length]

    // Create the contract code
    CREATION_CODE_FROM_MEMORY(0x00)   // [i, _data, &_data, _data.length]

    // Deploy the contract
    dup4 0x16 add                     // [size, i, _data, &_data, _data.length]
    0x00                              // [offset, size, i, _data, &_data, _data.length]
    0x00                              // [value, offset, size, i, _data, &_data, _data.length]
    create                            // [address, i, _data, &_data, _data.length]

    // Check that the address is non-zero
    dup1 iszero iszero success jumpi  // [address, i, _data, &_data, _data.length]
    0x00 dup1 revert
    success:

    // Clean the stack and return the address
    swap4 pop pop pop pop            // [address]
}

/// @notice Reads the contents of the `_pointer` code as data, skips the first byte
/// @dev The function is intended for reading pointers generated by `write`
/// @param _pointer to be read
/// @return data read from `_pointer` contract
#define macro SSTORE2_READ() = takes (1) returns (1) {
  // Input Stack: [_pointer]
  // We start at 1 because the first byte are zeros to prevent the contract from being called
  0x01                                // [_start, _pointer]
  [TYPE_UINT_256_MAX]                 // [_end, _start, _pointer]
  swap2                               // [_pointer, _start, _end]
  CODE_AT()                           // [code]
}


/// @notice Reads the contents of the `_pointer` code as data, skips the first byte
/// @dev The function is intended for reading pointers generated by `write`
/// @param _pointer to be read
/// @param _start number of bytes to skip
/// @return data read from `_pointer` contract
#define macro SSTORE2_READ_AT() = takes (2) returns (1) {
  // Input Stack: [_pointer, _start]
  swap1                               // [_start, _pointer]
  [TYPE_UINT_256_MAX]                 // [_end, _start, _pointer]
  swap2                               // [_pointer, _start, _end]
  CODE_AT()                           // [code]
}

/// @notice Reads the contents of the `_pointer` code as data, skips the first byte 
/// @dev The function is intended for reading pointers generated by `write`
/// @param _pointer to be read
/// @param _start number of bytes to skip
/// @param _end index before which to end extraction
/// @return data read from `_pointer` contract
#define macro SSTORE2_READ_BETWEEN() = takes (3) returns (1) {
  // Input Stack: [_pointer, _start, _end]
  CODE_AT()                           // [code]
}

