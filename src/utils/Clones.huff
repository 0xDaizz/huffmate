/// @title Clones
/// @notice SPDX-License-Identifier: MIT
/// @author Maddiaa <https://github.com/cheethas>
/// @notice https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for deploying minimal proxy contracts, also known as "clones".
/// @notice To simply and cheaply clone contract functionality in an immutable way, this standard specifies
///         a minimal bytecode implementation that delegates all calls to a known, fixed address.
///
/// @notice The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`
///         (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the
///         deterministic method.
/// @notice Adapted from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/Clones.sol)


#include "./CommonErrors.huff"

// BEFORE ADDRESS
//--------------------------------------------------------------------------------//
// Opcode     | Opcode + Arguments    | Description      | Stack View             //
//--------------------------------------------------------------------------------//
// 0x3d       |  0x36                 | RETURNDATASIZE   | 0                      //
// 0x60       |  0x602d               | PUSH1 0x2d       | 0x2d 0                 //
// 0x80       |  0x36                 | DUP1             | 0x2d 0x2d 0            //
// 0x60       |  0x600a               | PUSH1 0x0a       | 0x0a 0x2d 0x2d 0       //
// 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 0x0a 0x2d 0x2d 0     //
// 0x39       |  0x39                 | CODECOPY         | 0x2d 0                 //
// 0x81       |  0x81                 | DUP2             | 0 0x2d 0               //
// 0xf3       |  0xf3                 | RETURN           | 0                      //

// 0x36       |  0x36                 | CALLDATASIZE     | size                   //
// 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 size                 //
// 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 0 size               //
// 0x37       |  0x37                 | CALLDATACOPY     |                        //
// 0x3d       |  0x3d                 | RETURNDATASIZE   | 0                      //
// 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 0                    //
// 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 0 0                  //
// 0x36       |  0x36                 | CALLDATASIZE     | size 0 0 0             //
// 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 size 0 0 0           //
// 0x73       |  0x73                 | PUSH20 <addr>    | addr 0 size 0 0 0      //

// AFTER ADDRESS
//--------------------------------------------------------------------------------//
// Opcode     | Opcode + Arguments    | Description      | Stack View             //
//--------------------------------------------------------------------------------//
// 0x5a       |  0x5a                 | GAS              | gas addr 0 size 0 0 0  //
// 0xf4       |  0xf4                 | DELEGATECALL     | success 0              //
// 0x3d       |  0x3d                 | RETURNDATASIZE   | rds success 0          //
// 0x82       |  0x82                 | DUP3             | 0 rds success 0        //
// 0x80       |  0x80                 | DUP1             | 0 0 rds success 0      //
// 0x3e       |  0x3e                 | RETURNDATACOPY   | success 0              //
// 0x90       |  0x90                 | SWAP1            | 0 success              //
// 0x3d       |  0x3d                 | RETURNDATASIZE   | rds 0 success          //
// 0x91       |  0x91                 | SWAP2            | success rds 0          //
// 0x60       |  0x602b               | PUSH1 0x2b       | 0x2b success rds 0     //
// 0x57       |  0x57                 | JUMPI            | Revert if success == 0 //
// 0xfd       |  0xfd                 | REVERT           |                        //
// 0x5b       |  0x5b                 | JUMPDEST         |                        //
// 0xf3       |  0xf3                 | RETURN           |                        //
//--------------------------------------------------------------------------------//

#define constant BYTECODE_BEFORE_ADDRESS = 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000
#define constant BYTECODE_BEFORE_ADDRESS_NO_PADDING = 0x3d602d80600a3d3981f3363d3d373d3d3d363d73

#define constant BYTECODE_AFTER_ADDRESS = 0x5af43d82803e903d91602b57fd5bf3
#define constant BYTECODE_AFTER_ADDRESS_WITH_PADDING = 0x5af43d82803e903d91602b57fd5bf3ff


// Can remain inside the scratch space so no memory pointer is required
#define macro CLONE_MACRO(deploy_opcode) = takes(1) returns(0) {
    // Takes 1: Implementation 

    // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes
    // of the `implementation` address with the bytecode before the address.
    dup1            // [implementation]
    0x60 shl        // [RightPad(implementation), implementation]
    0xe8 shr        // []

    // TODO: Expand and explain this
    [BYTECODE_BEFORE_ADDRESS] 
    or
    0x00 mstore     // [implementation]

    // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.
    0x78 shl        // [rightpad(implementation)] 
    
    // TODO: Expand and explain this
    [BYTECODE_AFTER_ADDRESS]
    or
    0x20
    mstore 

    0x37
    0x09
    0x00
    <deploy_opcode>


    // TODO: clean stack
    iszero eq create_failed jumpi
    continue jump

    create_failed:
        DEPLOYMENT_FAILED(0x00)

    continue:
}

#define macro CLONE() = takes(1) returns(0) {
    CLONE_MACRO(create)
}

#define macro CLONE_DETERMINISTIC() = takes(2) returns(0) {
    CLONE_MACRO(create2)
}

// Memory pointer required as this function nukes memory and is part of a library
#define macro PREDICT_DETERMINISTIC_ADDRESS(ptr) = takes(3) returns(0) {
    // stack: [implementation, salt]

    address       

    /// place the deployer in memory
    <ptr> 0x38 add
    mstore

    
    [BYTECODE_AFTER_ADDRESS_WITH_PADDING]
    <ptr> 0x24 add
    mstore

    // Place implementation in memory
    <ptr> 0x14 add
    mstore

    [BYTECODE_BEFORE_ADDRESS_NO_PADDING]
    <ptr> mstore

    // Place the salt in memory
    <ptr> 0x58 add
    mstore

    // Hash and then store in memory
    0x37
    <ptr> 0x0c add
    sha3

    <ptr> 0x78 add
    mstore 


    // Do I have to shift the bytes here
    0x55
    <ptr> 0x43 add
    sha3
}