/// @title Clones
/// @notice SPDX-License-Identifier: MIT
/// @author Maddiaa <https://github.com/cheethas>
/// @notice https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for deploying minimal proxy contracts, also known as "clones".
/// @notice To simply and cheaply clone contract functionality in an immutable way, this standard specifies
///         a minimal bytecode implementation that delegates all calls to a known, fixed address.
///
/// @notice The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`
///         (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the
///         deterministic method.
/// @notice Adapted from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/Clones.sol)


#include "./CommonErrors.huff"


#define constant BYTECODE_BEFORE_ADDRESS = 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000
#define constant BYTECODE_BEFORE_ADDRESS_NO_PADDING = 0x3d602d80600a3d3981f3363d3d373d3d3d363d73

#define constant BYTECODE_AFTER_ADDRESS = 0x5af43d82803e903d91602b57fd5bf3
#define constant BYTECODE_AFTER_ADDRESS_WITH_PADDING = 0x5af43d82803e903d91602b57fd5bf3ff


// Can remain inside the scratch space so no memory pointer is required
#define macro CLONE_MACRO(deploy_opcode) = takes(1) returns(0) {
    // Takes 1: Implementation 

    // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes
    // of the `implementation` address with the bytecode before the address.
    dup1            // [implementation]
    0x60 shl        // [RightPad(implementation), implementation]
    0xe8 shr        // []

    // TODO: Expand and explain this
    [BYTECODE_BEFORE_ADDRESS] 
    or
    0x00 mstore     // [implementation]

    // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.
    0x78 shl        // [rightpad(implementation)] 
    
    // TODO: Expand and explain this
    [BYTECODE_AFTER_ADDRESS]
    or
    0x20
    mstore 

    0x37
    0x09
    0x00
    <deploy_opcode>


    // TODO: clean stack
    iszero eq create_failed jumpi
    continue jump

    create_failed:
        DEPLOYMENT_FAILED(0x00)

    continue:
}

#define macro CLONE() = takes(1) returns(0) {
    CLONE_MACRO(create)
}

#define macro CLONE_DETERMINISTIC() = takes(2) returns(0) {
    CLONE_MACRO(create2)
}

// Memory pointer required as this function nukes memory and is part of a library
#define macro PREDICT_DETERMINISTIC_ADDRESS(ptr) = takes(3) returns(0) {
    // stack: [implementation, salt]

    address       

    /// place the deployer in memory
    <ptr> 0x38 add
    mstore

    
    [BYTECODE_AFTER_ADDRESS_WITH_PADDING]
    <ptr> 0x24 add
    mstore

    // Place implementation in memory
    <ptr> 0x14 add
    mstore

    [BYTECODE_BEFORE_ADDRESS_NO_PADDING]
    <ptr> mstore

    // Place the salt in memory
    <ptr> 0x58 add
    mstore

    // Hash and then store in memory
    0x37
    <ptr> 0x0c add
    sha3

    <ptr> 0x78 add
    mstore 


    // Do I have to shift the bytes here
    0x55
    <ptr> 0x43 add
    sha3
}