#define function getJumpdestMem(uint256) view returns (uint256)
#define function getJumpdestStack(uint256) view returns (uint256)
#define function getJumpdestMemPacked(uint256) view returns (uint256)
#define function getJumpdestStackPacked(uint256) view returns (uint256)

#define jumptable TEST_TABLE {
    test_label_a test_label_b test_label_c test_label_d
}

#define jumptable__packed TEST_TABLE_PACKED {
    test_label_a test_label_b test_label_c test_label_d
}

#define macro GET_JUMPDEST_MEM_WRAPPER() = takes (0) returns (0) {
    __tablestart(TEST_TABLE)        // [table_start]
    0x04 calldataload               // [n, table_start]

    // Load a jumpdest inside of `TEST_TABLE` at index `n` into
    // memory at 0x00.
    LOAD_FROM_JT(0x00)              // []
    0x20 0x00 return
}

#define macro GET_JUMPDEST_STACK_WRAPPER() = takes (0) returns (0) {
    __tablestart(TEST_TABLE)        // [table_start]
    0x04 calldataload               // [n, table_start]
    RETRIEVE_FROM_JT()              // [jumpdest_pc]

    // Store our jumpdest_pc in memory & return it
    0x00 mstore                     // []
    0x20 0x00 return
}

#define macro GET_JUMPDEST_MEM_PACKED_WRAPPER() = takes (0) returns (0) {
    __tablestart(TEST_TABLE_PACKED) // [table_start]
    0x04 calldataload               // [n, table_start]

    // Store the retrieved jumpdest at 0x00 in memory.
    // Since `LOAD_FROM_PACKED_JT` only retrieves 2 bytes
    // from the contract's code in the `codecopy` op, we 
    // need to pass our desired memory pointer + 0x1e (30 bytes)
    LOAD_FROM_PACKED_JT(0x1e)       // []
    0x20 0x00 return
}

#define macro GET_JUMPDEST_STACK_PACKED_WRAPPER() = takes (0) returns (0) {
    __tablestart(TEST_TABLE_PACKED) // [table_start]
    0x04 calldataload               // [n, table_start]
    RETRIEVE_FROM_PACKED_JT()       // [jumpdest_pc]

    // Store our jumpdest_pc in memory & return it
    0x00 mstore                     // []
    0x20 0x00 return
}

#define macro MAIN() = takes (0) returns (0) {
    pc calldataload 0xE0 shr
    dup1 __FUNC_SIG(getJumpdestMem)         eq get_jumpdest_mem          jumpi
    dup1 __FUNC_SIG(getJumpdestStack)       eq get_jumpdest_stack        jumpi
    dup1 __FUNC_SIG(getJumpdestMemPacked)   eq get_jumpdest_mem_packed   jumpi
    dup1 __FUNC_SIG(getJumpdestStackPacked) eq get_jumpdest_stack_packed jumpi

    // Revert if no function signature matched
    test_label_d jump

    get_jumpdest_mem:
        GET_JUMPDEST_MEM_WRAPPER()
    get_jumpdest_stack:
        GET_JUMPDEST_MEM_WRAPPER()
    get_jumpdest_mem_packed:
        GET_JUMPDEST_MEM_PACKED_WRAPPER()
    get_jumpdest_stack_packed:
        GET_JUMPDEST_STACK_PACKED_WRAPPER()

    // Test labels included in `TEST_TABLE`
    test_label_a:
    test_label_b:
    test_label_c:
    test_label_d:
        0x00 dup1 revert
}


/// @title JumpTableUtil
/// @notice SPDX-License-Identifier: MIT
/// @author clabby <https://github.com/clabby>
/// @notice Utility macros for retrieving jumpdest pcs from jump tables

/// @notice Loads a jumpdest stored in a jumptable into memory at `mem_ptr`
///
/// @param mem_ptr The memory location to load the 2 byte jumpdest into
/// @param index The index of the jumpdest within the jumptable
/// @param table_start The offset of the jumptable in the contract's bytecode
#define macro LOAD_FROM_JT(mem_ptr) = takes (2) returns (1) {
    // Input stack:       [index, table_start]

    0x05 shl add       // [table_start + index * 0x20]
    0x20 swap1         // [table_start + index * 0x20, 0x20]
    <mem_ptr>          // [mem_ptr, table_start + index * 0x20, 0x20]
    codecopy           // []

    // Return stack:      []
}

/// @notice Retrieves a jumpdest stored in a jumptable and puts it on the stack
///
/// @param index The index of the jumpdest within the jumptable
/// @param table_start The offset of the jumptable in the contract's bytecode
#define macro RETRIEVE_FROM_JT() = takes (2) returns (1) {
    // Input stack:       [index, table_start]

    LOAD_FROM_JT(0x00) // []
    0x00 mload         // [res]

    // Return stack:      [res]
}

/// @notice Loads a jumpdest stored in a packed jumptable into memory at `mem_ptr`
/// @dev This macro only loads 2 bytes from the contract code, so make sure to account
///      for this when passing a `mem_ptr`. I.e., if we want to store the jumpdest pc
///      at offset `x`, we would pass in `x + 0x1e` as the `mem_ptr` argument.
///
/// @param mem_ptr The memory location to load the 2 byte jumpdest into
/// @param index The index of the jumpdest within the packed jumptable
/// @param table_start The offset of the packed jumptable in the contract's bytecode
#define macro LOAD_FROM_PACKED_JT(mem_ptr) = takes (2) returns (1) {
    // Input stack:       [index, table_start]

    0x01 shl add       // [table_start + index * 0x02]
    0x02 swap1         // [table_start + index * 0x02, 0x02]
    <mem_ptr>          // [mem_ptr, table_start + index * 0x02, 0x02]
    codecopy           // []

    // Return stack:      []
}

/// @notice Retrieves a jumpdest stored in a packed jumptable and puts it on the stack
///
/// @param index The index of the jumpdest within the packed jumptable
/// @param table_start The offset of the packed jumptable in the contract's bytecode
#define macro RETRIEVE_FROM_PACKED_JT() = takes (2) returns (1) {
    // Input stack:       [index, table_start]

    LOAD_FROM_PACKED_JT(0x1e)
    //                    []
    0x00 mload         // [res]

    // Return stack:      [res]
}
